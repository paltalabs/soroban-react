"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTransaction = void 0;
const stellar_sdk_1 = require("@stellar/stellar-sdk");
const bigNumber_1 = require("@trezor/utils/lib/bigNumber");
const transformSigner = (signer) => {
    let type = 0;
    let key;
    const { weight } = signer;
    if ('ed25519PublicKey' in signer) {
        const keyPair = stellar_sdk_1.Keypair.fromPublicKey(signer.ed25519PublicKey);
        key = keyPair.rawPublicKey().toString('hex');
    }
    if ('preAuthTx' in signer && signer.preAuthTx instanceof Buffer) {
        type = 1;
        key = signer.preAuthTx.toString('hex');
    }
    if ('sha256Hash' in signer && signer.sha256Hash instanceof Buffer) {
        type = 2;
        key = signer.sha256Hash.toString('hex');
    }
    return {
        type,
        key,
        weight,
    };
};
const transformAsset = (asset) => {
    if (asset.isNative()) {
        return {
            type: 0,
            code: asset.getCode(),
        };
    }
    return {
        type: asset.getAssetType() === 'credit_alphanum4' ? 1 : 2,
        code: asset.getCode(),
        issuer: asset.getIssuer(),
    };
};
const transformAmount = (amount) => new bigNumber_1.BigNumber(amount).times(10000000).toString();
const transformMemo = (memo) => {
    switch (memo.type) {
        case stellar_sdk_1.MemoText:
            return { type: 1, text: memo.value.toString('utf-8') };
        case stellar_sdk_1.MemoID:
            return { type: 2, id: memo.value.toString('utf-8') };
        case stellar_sdk_1.MemoHash:
            return { type: 3, hash: memo.value.toString('hex') };
        case stellar_sdk_1.MemoReturn:
            return { type: 4, hash: memo.value.toString('hex') };
        default:
            return { type: 0 };
    }
};
const transformTimebounds = (timebounds) => {
    if (!timebounds)
        return undefined;
    return {
        minTime: Number.parseInt(timebounds.minTime, 10),
        maxTime: Number.parseInt(timebounds.maxTime, 10),
    };
};
const transformTransaction = (path, transaction) => {
    const amounts = [
        'amount',
        'sendMax',
        'destAmount',
        'sendAmount',
        'destMin',
        'startingBalance',
        'limit',
        'buyAmount',
    ];
    const assets = ['asset', 'sendAsset', 'destAsset', 'selling', 'buying', 'line'];
    const operations = transaction.operations.map((o, i) => {
        const operation = Object.assign({}, o);
        if (operation.signer) {
            operation.signer = transformSigner(operation.signer);
        }
        if (operation.path) {
            operation.path = operation.path.map(transformAsset);
        }
        if (typeof operation.price === 'string') {
            const xdrOperation = transaction.tx.operations()[i];
            operation.price = {
                n: xdrOperation.body().value().price().n(),
                d: xdrOperation.body().value().price().d(),
            };
        }
        amounts.forEach(field => {
            if (typeof operation[field] === 'string') {
                operation[field] = transformAmount(operation[field]);
            }
        });
        assets.forEach(field => {
            if (operation[field]) {
                operation[field] = transformAsset(operation[field]);
            }
        });
        if (operation.type === 'allowTrust') {
            const allowTrustAsset = new stellar_sdk_1.Asset(operation.assetCode, operation.trustor);
            operation.assetType = transformAsset(allowTrustAsset).type;
        }
        if (operation.type === 'manageData' && operation.value) {
            operation.value = operation.value.toString('hex');
        }
        if (operation.type === 'manageBuyOffer') {
            operation.amount = operation.buyAmount;
            delete operation.buyAmount;
        }
        operation.type = o.type;
        return operation;
    });
    return {
        path,
        networkPassphrase: transaction.networkPassphrase,
        transaction: {
            source: transaction.source,
            fee: Number.parseInt(transaction.fee, 10),
            sequence: transaction.sequence,
            memo: transformMemo(transaction.memo),
            timebounds: transformTimebounds(transaction.timeBounds),
            operations,
        },
    };
};
exports.transformTransaction = transformTransaction;
exports.default = exports.transformTransaction;
//# sourceMappingURL=index.js.map