"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElectrumClient = void 0;
const tslib_1 = require("tslib");
const utxo_lib_1 = require("@trezor/utxo-lib");
const batching_1 = require("./batching");
const KEEP_ALIVE_INTERVAL = 120 * 1000;
const selectNetwork = (shortcut) => {
    switch (shortcut) {
        case 'REGTEST':
            return utxo_lib_1.networks.regtest;
        case 'TEST':
            return utxo_lib_1.networks.testnet;
        default:
            return utxo_lib_1.networks.bitcoin;
    }
};
class ElectrumClient extends batching_1.BatchingJsonRpcClient {
    constructor() {
        super(...arguments);
        this.timeLastCall = 0;
    }
    connect(socket, options) {
        const _super = Object.create(null, {
            connect: { get: () => super.connect }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            this.timeLastCall = 0;
            this.options = options;
            this.network = selectNetwork(options.coin);
            const { name, protocolVersion } = options.client;
            yield _super.connect.call(this, socket, options);
            try {
                this.version = yield this.request('server.version', name, protocolVersion);
                if (((_a = this.version[0]) === null || _a === void 0 ? void 0 : _a.startsWith('ElectrumPersonalServer')) ||
                    ((_b = this.version[0]) === null || _b === void 0 ? void 0 : _b.startsWith('electrs-esplora'))) {
                    this.batchingDisabled = true;
                }
                this.on('blockchain.headers.subscribe', this.onBlock.bind(this));
                this.lastBlock = yield this.request('blockchain.headers.subscribe');
            }
            catch (err) {
                this.socket = undefined;
                throw new Error(`Communication with Electrum server failed: [${err}]`);
            }
            this.keepAlive();
        });
    }
    getInfo() {
        var _a;
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.url) && this.version && this.lastBlock && this.network) {
            return {
                url: this.options.url,
                version: this.version,
                block: this.lastBlock,
                coin: this.options.coin,
                network: this.network,
            };
        }
    }
    onBlock(blocks) {
        const [last] = blocks.sort((a, b) => b.height - a.height);
        if (last)
            this.lastBlock = last;
    }
    request(method, ...params) {
        this.timeLastCall = new Date().getTime();
        return super.request(method, ...params);
    }
    keepAlive() {
        if (!this.socket)
            return;
        this.keepAliveHandle = setInterval(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.timeLastCall !== 0 &&
                new Date().getTime() > this.timeLastCall + KEEP_ALIVE_INTERVAL / 2) {
                yield this.request('server.ping').catch(err => {
                    console.error(`Ping to server failed: [${err}]`);
                    this.close();
                });
            }
        }), KEEP_ALIVE_INTERVAL);
    }
    onClose() {
        super.onClose();
        if (this.keepAliveHandle)
            clearInterval(this.keepAliveHandle);
    }
}
exports.ElectrumClient = ElectrumClient;
//# sourceMappingURL=electrum.js.map