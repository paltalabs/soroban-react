"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachingElectrumClient = void 0;
const tslib_1 = require("tslib");
const electrum_1 = require("./electrum");
class CachingElectrumClient extends electrum_1.ElectrumClient {
    constructor() {
        super();
        this.cache = {};
        this.statuses = {};
        this.cached = 0;
        this.total = 0;
        this.logTimer = setInterval(() => {
            this.log(`Caching effectiveness: ${this.cached}/${this.total}`);
            this.log('Subscription count: ', Object.keys(this.statuses).length);
        }, 60000);
    }
    cacheRequest(status, method, params) {
        const _super = Object.create(null, {
            request: { get: () => super.request }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const descriptor = [method, ...params].join(':');
            const cached = this.cache[descriptor];
            if (cached) {
                const [cachedStatus, cachedResponse] = cached;
                if (cachedStatus === status) {
                    this.cached++;
                    return cachedResponse;
                }
            }
            const response = yield _super.request.call(this, method, ...params);
            this.cache[descriptor] = [status, response];
            return response;
        });
    }
    trySubscribe(scripthash) {
        const _super = Object.create(null, {
            request: { get: () => super.request }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const status = this.statuses[scripthash];
            if (status !== undefined) {
                return status;
            }
            const newStatus = yield _super.request.call(this, 'blockchain.scripthash.subscribe', scripthash);
            this.statuses[scripthash] = newStatus;
            return newStatus;
        });
    }
    request(method, ...params) {
        const _super = Object.create(null, {
            request: { get: () => super.request }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            this.total++;
            switch (method) {
                case 'blockchain.scripthash.get_history':
                case 'blockchain.scripthash.get_balance':
                case 'blockchain.scripthash.listunspent': {
                    const [scripthash] = params;
                    const status = yield this.trySubscribe(scripthash);
                    return this.cacheRequest(status, method, params);
                }
                case 'blockchain.transaction.get': {
                    const curBlock = (_a = this.lastBlock) === null || _a === void 0 ? void 0 : _a.hex;
                    if (curBlock === undefined)
                        break;
                    return this.cacheRequest(curBlock, method, params);
                }
                case 'blockchain.scripthash.subscribe': {
                    const [scripthash] = params;
                    return this.trySubscribe(scripthash);
                }
                case 'blockchain.scripthash.unsubscribe': {
                    const [scripthash] = params;
                    delete this.statuses[scripthash];
                    return _super.request.call(this, method, ...params);
                }
                default:
                    break;
            }
            return _super.request.call(this, method, ...params);
        });
    }
    response(response) {
        const { method, params } = response;
        switch (method) {
            case 'blockchain.scripthash.subscribe': {
                const [scripthash, status] = params;
                this.statuses[scripthash] = status;
                break;
            }
            default:
                break;
        }
        super.response(response);
    }
    onClose() {
        super.onClose();
        clearInterval(this.logTimer);
    }
}
exports.CachingElectrumClient = CachingElectrumClient;
//# sourceMappingURL=caching.js.map