"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sumAddressValues = void 0;
const tslib_1 = require("tslib");
const utxo_lib_1 = require("@trezor/utxo-lib");
const blockchain_link_utils_1 = require("@trezor/blockchain-link-utils");
const blockbook_1 = require("@trezor/blockchain-link-utils/lib/blockbook");
const utils_1 = require("../utils");
const PAGE_SIZE_DEFAULT = 25;
const getBalances = (client) => (addresses) => Promise.all(addresses.map((_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ address, path, history, scripthash, empty }) {
    const { confirmed, unconfirmed } = history.length
        ? yield client.request('blockchain.scripthash.get_balance', scripthash)
        : {
            confirmed: 0,
            unconfirmed: 0,
        };
    return {
        address,
        path,
        history,
        empty,
        confirmed,
        unconfirmed,
    };
})));
const getPagination = (perPage, txs) => ({
    index: 1,
    size: perPage,
    total: Math.ceil(txs.length / perPage),
});
const sumAddressValues = (transactions, address, getVinVouts) => transactions
    .flatMap(tx => getVinVouts(tx)
    .filter(({ addresses }) => addresses === null || addresses === void 0 ? void 0 : addresses.includes(address))
    .map(({ value }) => (value ? Number.parseFloat(value) : 0)))
    .reduce((a, b) => a + b, 0);
exports.sumAddressValues = sumAddressValues;
const getAccountInfo = (client, payload) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { descriptor, details = 'basic', pageSize = PAGE_SIZE_DEFAULT } = payload;
    const network = (_a = client.getInfo()) === null || _a === void 0 ? void 0 : _a.network;
    const parsed = (0, utils_1.tryGetScripthash)(descriptor, network);
    if (parsed.valid) {
        const { confirmed, unconfirmed, history } = yield Promise.all([
            client.request('blockchain.scripthash.get_balance', parsed.scripthash),
            client.request('blockchain.scripthash.get_history', parsed.scripthash),
        ]).then(([{ confirmed, unconfirmed }, history]) => ({
            confirmed,
            unconfirmed,
            history,
        }));
        const historyUnconfirmed = history.filter(r => r.height <= 0).length;
        const transactions = details === 'txs'
            ? yield (0, utils_1.getTransactions)(client, history)
                .then(txs => txs.map(tx => (0, blockbook_1.transformTransaction)(tx, descriptor)))
                .then(blockchain_link_utils_1.sortTxsFromLatest)
            : undefined;
        return {
            descriptor,
            balance: confirmed.toString(),
            availableBalance: (confirmed + unconfirmed).toString(),
            empty: !history.length,
            history: {
                total: history.length - historyUnconfirmed,
                unconfirmed: historyUnconfirmed,
                transactions,
            },
            page: details === 'txs' ? getPagination(pageSize, transactions !== null && transactions !== void 0 ? transactions : []) : undefined,
        };
    }
    const discover = (0, utils_1.discoverAddress)(client);
    const receive = yield (0, utxo_lib_1.discovery)(discover, descriptor, 'receive', network).then(getBalances(client));
    const change = yield (0, utxo_lib_1.discovery)(discover, descriptor, 'change', network).then(getBalances(client));
    const batch = receive.concat(change);
    const [confirmed, unconfirmed] = batch.reduce(([c, u], { confirmed, unconfirmed }) => [c + confirmed, u + unconfirmed], [0, 0]);
    const history = batch.flatMap(({ history }) => history);
    const historyUnconfirmed = history.filter(r => r.height <= 0).length;
    const transformAddressInfo = ({ address, path, history, confirmed }) => ({
        address,
        path,
        transfers: history.length,
        balance: confirmed.toString(),
    });
    const addresses = {
        change: change.map(transformAddressInfo),
        unused: receive.filter(recv => !recv.history.length).map(transformAddressInfo),
        used: receive.filter(recv => recv.history.length).map(transformAddressInfo),
    };
    const transactions = ['tokenBalances', 'txids', 'txs'].includes(details)
        ? yield (0, utils_1.getTransactions)(client, history)
            .then(txs => txs.map(tx => (0, blockbook_1.transformTransaction)(tx, addresses)))
            .then(blockchain_link_utils_1.sortTxsFromLatest)
        : [];
    const extendAddressInfo = ({ address, path, transfers, balance }) => (Object.assign({ address,
        path,
        transfers }, (['tokenBalances', 'txids', 'txs'].includes(details) && transfers
        ? {
            balance,
            sent: (0, exports.sumAddressValues)(transactions, address, tx => tx.details.vin).toString(),
            received: (0, exports.sumAddressValues)(transactions, address, tx => tx.details.vout).toString(),
        }
        : {})));
    return {
        descriptor,
        balance: confirmed.toString(),
        availableBalance: (confirmed + unconfirmed).toString(),
        empty: !history.length,
        history: {
            total: history.length - historyUnconfirmed,
            unconfirmed: historyUnconfirmed,
            transactions: details === 'txs' ? transactions : undefined,
        },
        addresses: details !== 'basic'
            ? {
                change: addresses.change.map(extendAddressInfo),
                unused: addresses.unused.map(extendAddressInfo),
                used: addresses.used.map(extendAddressInfo),
            }
            : undefined,
        page: details === 'txs' ? getPagination(pageSize, transactions) : undefined,
    };
});
exports.default = getAccountInfo;
//# sourceMappingURL=getAccountInfo.js.map