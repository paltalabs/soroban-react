"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Solana;
const tslib_1 = require("tslib");
const token_1 = require("@solana-program/token");
const web3_js_1 = require("@solana/web3.js");
const errors_1 = require("@trezor/blockchain-link-types/lib/constants/errors");
const constants_1 = require("@trezor/blockchain-link-types/lib/constants");
const blockchain_link_utils_1 = require("@trezor/blockchain-link-utils");
const utils_1 = require("@trezor/utils");
const solana_1 = require("@trezor/blockchain-link-utils/lib/solana");
const env_utils_1 = require("@trezor/env-utils");
const fee_1 = require("./fee");
const baseWorker_1 = require("../baseWorker");
function nonNullable(value) {
    return value !== null && value !== undefined;
}
const getAllSignatures = (api_1, descriptor_1, ...args_1) => tslib_1.__awaiter(void 0, [api_1, descriptor_1, ...args_1], void 0, function* (api, descriptor, fullHistory = true) {
    let lastSignature;
    let keepFetching = true;
    let allSignatures = [];
    const limit = 100;
    while (keepFetching) {
        const signaturesInfos = yield api.rpc
            .getSignaturesForAddress((0, web3_js_1.address)(descriptor), {
            before: lastSignature === null || lastSignature === void 0 ? void 0 : lastSignature.signature,
            limit,
        })
            .send();
        const signatures = signaturesInfos.map(info => ({
            signature: info.signature,
            slot: info.slot,
        }));
        lastSignature = signatures[signatures.length - 1];
        keepFetching = signatures.length === limit && fullHistory;
        allSignatures = [...allSignatures, ...signatures];
    }
    return allSignatures;
});
const fetchTransactionPage = (api, signatures) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return (yield Promise.all(signatures.map(signature => api.rpc
        .getTransaction(signature, {
        encoding: 'jsonParsed',
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed',
    })
        .send()))).filter(nonNullable);
});
const isValidTransaction = (tx) => !!(tx && tx.meta && tx.transaction && tx.blockTime);
const pushTransaction = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const rawTx = request.payload.startsWith('0x') ? request.payload.slice(2) : request.payload;
    const api = yield request.connect();
    const txByteArray = (0, web3_js_1.getBase16Encoder)().encode(rawTx);
    const transaction = (0, web3_js_1.getTransactionDecoder)().decode(txByteArray);
    (0, web3_js_1.assertTransactionIsFullySigned)(transaction);
    const compiledMessage = (0, web3_js_1.getCompiledTransactionMessageDecoder)().decode(transaction.messageBytes);
    const message = (0, web3_js_1.decompileTransactionMessage)(compiledMessage);
    if ((0, web3_js_1.isDurableNonceTransaction)(message)) {
        throw new Error('Unimplemented: Confirming durable nonce transactions');
    }
    let transactionWithBlockhashLifetime = transaction;
    if (message.lifetimeConstraint === undefined) {
        const { value: { blockhash, lastValidBlockHeight }, } = yield api.rpc.getLatestBlockhash({ commitment: 'finalized' }).send();
        transactionWithBlockhashLifetime = Object.assign(Object.assign({}, transactionWithBlockhashLifetime), { lifetimeConstraint: { blockhash, lastValidBlockHeight } });
    }
    else {
        transactionWithBlockhashLifetime = Object.assign(Object.assign({}, transactionWithBlockhashLifetime), { lifetimeConstraint: message.lifetimeConstraint });
    }
    try {
        const signature = (0, web3_js_1.getSignatureFromTransaction)(transaction);
        const sendAndConfirmTransaction = (0, web3_js_1.sendAndConfirmTransactionFactory)(api);
        yield sendAndConfirmTransaction(transactionWithBlockhashLifetime, {
            commitment: 'confirmed',
            skipPreflight: false,
        });
        return {
            type: constants_1.RESPONSES.PUSH_TRANSACTION,
            payload: signature,
        };
    }
    catch (error) {
        if ((0, web3_js_1.isSolanaError)(error, web3_js_1.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {
            throw new Error('Please make sure that you submit the transaction within 1 minute after signing.');
        }
        if ((0, web3_js_1.isSolanaError)(error, web3_js_1.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT) ||
            (0, web3_js_1.isSolanaError)(error, web3_js_1.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED) ||
            (0, web3_js_1.isSolanaError)(error, web3_js_1.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR)) {
            throw new Error('Solana backend connection failure. The backend might be inaccessible or the connection is unstable.');
        }
        if ((0, web3_js_1.isSolanaError)(error)) {
            throw new Error(`Solana error code: ${error.context.__code}. Please try again or contact support.`);
        }
        throw error;
    }
});
const getAccountInfo = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { payload } = request;
    const { details = 'basic' } = payload;
    const api = yield request.connect();
    const publicKey = (0, web3_js_1.address)(payload.descriptor);
    const getAllTxIds = (tokenAccountPubkeys) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const sortedTokenAccountPubkeys = tokenAccountPubkeys.sort();
        const allAccounts = [payload.descriptor, ...sortedTokenAccountPubkeys];
        const allTxIds = details === 'basic' || details === 'txs' || details === 'txids'
            ? Array.from(new Set((yield Promise.all(allAccounts.map(account => getAllSignatures(api, account, details !== 'basic'))))
                .flat()
                .sort((a, b) => Number(b.slot - a.slot))
                .map(it => it.signature)))
            : [];
        return allTxIds;
    });
    if (details === 'txids') {
        const txids = yield getAllTxIds(request.payload.tokenAccountsPubKeys || []);
        const account = {
            descriptor: payload.descriptor,
            balance: '0',
            availableBalance: '0',
            empty: txids.length === 0,
            history: {
                total: txids.length,
                unconfirmed: 0,
                txids,
            },
        };
        return {
            type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
            payload: account,
        };
    }
    const getTransactionPage = (txIds, tokenAccountsInfos) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (txIds.length === 0) {
            return [];
        }
        const transactionsPage = yield fetchTransactionPage(api, txIds);
        const tokenMetadata = yield request.getTokenMetadata();
        return transactionsPage
            .filter(isValidTransaction)
            .map(tx => blockchain_link_utils_1.solanaUtils.transformTransaction(tx, payload.descriptor, tokenAccountsInfos, tokenMetadata))
            .filter((tx) => !!tx);
    });
    const tokenAccounts = yield api.rpc
        .getTokenAccountsByOwner(publicKey, { programId: (0, web3_js_1.address)(solana_1.TOKEN_PROGRAM_PUBLIC_KEY) }, {
        encoding: 'jsonParsed',
    })
        .send();
    const allTxIds = yield getAllTxIds(tokenAccounts.value.map(a => a.pubkey));
    const pageNumber = payload.page ? payload.page - 1 : 0;
    const pageSize = payload.pageSize || 5;
    const pageStartIndex = pageNumber * pageSize;
    const pageEndIndex = Math.min(pageStartIndex + pageSize, allTxIds.length);
    const txIdPage = allTxIds.slice(pageStartIndex, pageEndIndex);
    const tokenAccountsInfos = tokenAccounts.value.map(a => {
        var _a, _b, _c, _d, _e;
        return ({
            address: a.pubkey,
            mint: (_b = (_a = a.account.data.parsed) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.mint,
            decimals: (_e = (_d = (_c = a.account.data.parsed) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.tokenAmount) === null || _e === void 0 ? void 0 : _e.decimals,
        });
    });
    const transactionPage = details === 'txs' ? yield getTransactionPage(txIdPage, tokenAccountsInfos) : undefined;
    let tokens = [];
    if (tokenAccounts.value.length > 0) {
        const tokenMetadata = yield request.getTokenMetadata();
        tokens = (0, solana_1.transformTokenInfo)(tokenAccounts.value, tokenMetadata);
    }
    const { value: balance } = yield api.rpc.getBalance(publicKey).send();
    let misc;
    if (details !== 'basic') {
        const { value: accountInfo } = yield api.rpc
            .getAccountInfo(publicKey, { encoding: 'base64' })
            .send();
        if (accountInfo) {
            const [accountDataEncoded] = accountInfo.data;
            const accountDataBytes = (0, web3_js_1.getBase64Encoder)().encode(accountDataEncoded);
            const accountDataLength = BigInt(accountDataBytes.byteLength);
            const rent = yield api.rpc.getMinimumBalanceForRentExemption(accountDataLength).send();
            misc = {
                owner: accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner,
                rent: Number(rent),
            };
        }
    }
    const isAccountEmpty = !(allTxIds.length || balance || tokens.length);
    const account = Object.assign({ descriptor: payload.descriptor, balance: balance.toString(), availableBalance: balance.toString(), empty: isAccountEmpty, history: {
            total: allTxIds.length,
            unconfirmed: 0,
            transactions: transactionPage,
            txids: txIdPage,
        }, page: transactionPage
            ? {
                total: allTxIds.length,
                index: pageNumber,
                size: transactionPage.length,
            }
            : undefined, tokens }, (misc ? { misc } : {}));
    const workerAccount = request.state.getAccount(payload.descriptor);
    if (workerAccount) {
        request.state.addAccounts([Object.assign(Object.assign({}, workerAccount), { tokens })]);
    }
    return {
        type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
        payload: account,
    };
});
const getInfo = (request, isTestnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const api = yield request.connect();
    const { value: { blockhash: blockHash, lastValidBlockHeight: blockHeight }, } = yield api.rpc.getLatestBlockhash({ commitment: 'finalized' }).send();
    const serverInfo = {
        testnet: isTestnet,
        blockHeight: Number(blockHeight),
        blockHash,
        shortcut: isTestnet ? 'dsol' : 'sol',
        url: api.clusterUrl,
        name: 'Solana',
        version: (yield api.rpc.getVersion().send())['solana-core'],
        decimals: 9,
    };
    return {
        type: constants_1.RESPONSES.GET_INFO,
        payload: Object.assign({}, serverInfo),
    };
});
const estimateFee = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const api = yield request.connect();
    const messageHex = (_a = request.payload.specific) === null || _a === void 0 ? void 0 : _a.data;
    const isCreatingAccount = (_b = request.payload.specific) === null || _b === void 0 ? void 0 : _b.isCreatingAccount;
    if (messageHex == null) {
        throw new Error('Could not estimate fee for transaction.');
    }
    const transaction = (0, web3_js_1.pipe)(messageHex, (0, web3_js_1.getBase16Encoder)().encode, (0, web3_js_1.getTransactionDecoder)().decode);
    const message = (0, web3_js_1.pipe)(transaction.messageBytes, (0, web3_js_1.getCompiledTransactionMessageDecoder)().decode);
    const priorityFee = yield (0, fee_1.getPriorityFee)(api.rpc, message, transaction.signatures);
    const baseFee = yield (0, fee_1.getBaseFee)(api.rpc, message);
    const accountCreationFee = isCreatingAccount
        ? yield api.rpc.getMinimumBalanceForRentExemption(BigInt((0, token_1.getTokenSize)())).send()
        : BigInt(0);
    const payload = [
        {
            feePerTx: new utils_1.BigNumber(baseFee.toString())
                .plus(priorityFee.fee)
                .plus(accountCreationFee.toString())
                .toString(10),
            feePerUnit: priorityFee.computeUnitPrice,
            feeLimit: priorityFee.computeUnitLimit,
        },
    ];
    return {
        type: constants_1.RESPONSES.ESTIMATE_FEE,
        payload,
    };
});
const BLOCK_SUBSCRIBE_INTERVAL_MS = 50000;
const subscribeBlock = (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ state, connect, post }) {
    if (state.getSubscription('block'))
        return { subscribed: true };
    const api = yield connect();
    const fetchBlock = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const { value: { blockhash: blockHash, lastValidBlockHeight: blockHeight }, } = yield api.rpc.getLatestBlockhash({ commitment: 'finalized' }).send();
        if (blockHeight) {
            post({
                id: -1,
                type: constants_1.RESPONSES.NOTIFICATION,
                payload: {
                    type: 'block',
                    payload: {
                        blockHeight: Number(blockHeight),
                        blockHash,
                    },
                },
            });
        }
    });
    fetchBlock();
    const interval = setInterval(fetchBlock, BLOCK_SUBSCRIBE_INTERVAL_MS);
    state.addSubscription('block', interval);
    return { subscribed: true };
});
const unsubscribeBlock = ({ state }) => {
    if (!state.getSubscription('block'))
        return;
    const interval = state.getSubscription('block');
    clearInterval(interval);
    state.removeSubscription('block');
};
const extractTokenAccounts = (accounts) => accounts
    .map(account => {
    var _a;
    return (((_a = account.tokens) === null || _a === void 0 ? void 0 : _a.map(token => {
        var _a;
        return ((_a = token.accounts) === null || _a === void 0 ? void 0 : _a.map(tokenAccount => ({
            descriptor: tokenAccount.publicKey,
        }))) || [];
    })) || []).flat();
})
    .flat();
const findTokenAccountOwner = (accounts, accountDescriptor) => accounts.find(account => {
    var _a;
    return (_a = account.tokens) === null || _a === void 0 ? void 0 : _a.find(token => { var _a; return (_a = token.accounts) === null || _a === void 0 ? void 0 : _a.find(tokenAccount => tokenAccount.publicKey === accountDescriptor); });
});
let NEXT_ACCOUNT_SUBSCRIPTION_ID = 0;
const ACCOUNT_SUBSCRIPTION_ABORT_CONTROLLERS = new Map();
function abortSubscription(id) {
    const abortController = ACCOUNT_SUBSCRIPTION_ABORT_CONTROLLERS.get(id);
    ACCOUNT_SUBSCRIPTION_ABORT_CONTROLLERS.delete(id);
    abortController === null || abortController === void 0 ? void 0 : abortController.abort();
}
const handleAccountNotification = (context, accountNotifications, account) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, accountNotifications_1, accountNotifications_1_1;
    var _b, e_1, _c, _d;
    var _e;
    const { connect, state, post, getTokenMetadata } = context;
    try {
        try {
            for (_a = true, accountNotifications_1 = tslib_1.__asyncValues(accountNotifications); accountNotifications_1_1 = yield accountNotifications_1.next(), _b = accountNotifications_1_1.done, !_b; _a = true) {
                _d = accountNotifications_1_1.value;
                _a = false;
                const _ = _d;
                const api = yield connect();
                const [lastSignatureResponse] = yield api.rpc
                    .getSignaturesForAddress((0, web3_js_1.address)(account.descriptor), {
                    limit: 1,
                })
                    .send();
                const lastSignature = lastSignatureResponse === null || lastSignatureResponse === void 0 ? void 0 : lastSignatureResponse.signature;
                if (!lastSignature)
                    return;
                const lastTx = yield api.rpc
                    .getTransaction(lastSignature, {
                    encoding: 'jsonParsed',
                    maxSupportedTransactionVersion: 0,
                    commitment: 'confirmed',
                })
                    .send();
                if (!lastTx || !isValidTransaction(lastTx)) {
                    return;
                }
                const tokenMetadata = yield getTokenMetadata();
                const tx = blockchain_link_utils_1.solanaUtils.transformTransaction(lastTx, account.descriptor, [], tokenMetadata);
                const descriptor = ((_e = findTokenAccountOwner(state.getAccounts(), account.descriptor)) === null || _e === void 0 ? void 0 : _e.descriptor) ||
                    account.descriptor;
                post({
                    id: -1,
                    type: constants_1.RESPONSES.NOTIFICATION,
                    payload: {
                        type: 'notification',
                        payload: {
                            descriptor,
                            tx,
                        },
                    },
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_a && !_b && (_c = accountNotifications_1.return)) yield _c.call(accountNotifications_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    catch (error) {
        console.error('Solana subscription error:', error);
        if ((0, web3_js_1.isSolanaError)(error, web3_js_1.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {
            if (account.subscriptionId)
                abortSubscription(account.subscriptionId);
            state.removeAccounts([account]);
            context.onNetworkDisconnect();
        }
    }
});
const subscribeAccounts = (context, accounts) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { connect, state } = context;
    const api = yield connect();
    const subscribedAccounts = state.getAccounts();
    const tokenAccounts = extractTokenAccounts(accounts);
    const newAccounts = [...accounts, ...tokenAccounts].filter(account => !subscribedAccounts.some(subscribedAccount => account.descriptor === subscribedAccount.descriptor));
    yield Promise.all(newAccounts.map((a) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const abortController = new AbortController();
        const accountNotifications = yield api.rpcSubscriptions
            .accountNotifications((0, web3_js_1.address)(a.descriptor), { commitment: 'confirmed' })
            .subscribe({ abortSignal: abortController.signal });
        const subscriptionId = NEXT_ACCOUNT_SUBSCRIPTION_ID++;
        ACCOUNT_SUBSCRIPTION_ABORT_CONTROLLERS.set(subscriptionId, abortController);
        const account = Object.assign(Object.assign({}, a), { subscriptionId });
        state.addAccounts([account]);
        handleAccountNotification(context, accountNotifications, account);
    })));
    return { subscribed: newAccounts.length > 0 };
});
const unsubscribeAccounts = ({ state }, accounts = []) => {
    const subscribedAccounts = state.getAccounts();
    accounts.forEach(a => {
        var _a;
        if (a.subscriptionId != null) {
            abortSubscription(a.subscriptionId);
            state.removeAccounts([a]);
        }
        (_a = a.tokens) === null || _a === void 0 ? void 0 : _a.forEach(t => {
            var _a;
            (_a = t.accounts) === null || _a === void 0 ? void 0 : _a.forEach(ta => {
                const tokenAccount = subscribedAccounts.find(sa => sa.descriptor === ta.publicKey);
                if ((tokenAccount === null || tokenAccount === void 0 ? void 0 : tokenAccount.subscriptionId) != null) {
                    abortSubscription(tokenAccount.subscriptionId);
                    state.removeAccounts([tokenAccount]);
                }
            });
        });
    });
};
const subscribe = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let response;
    switch (request.payload.type) {
        case 'block':
            response = yield subscribeBlock(request);
            break;
        case 'accounts':
            response = yield subscribeAccounts(request, request.payload.accounts);
            break;
        default:
            throw new errors_1.CustomError('worker_unknown_request', `+${request.type}`);
    }
    return {
        type: constants_1.RESPONSES.SUBSCRIBE,
        payload: response,
    };
});
const unsubscribe = (request) => {
    switch (request.payload.type) {
        case 'block':
            unsubscribeBlock(request);
            break;
        case 'accounts': {
            unsubscribeAccounts(request, request.payload.accounts);
            break;
        }
        default:
            throw new errors_1.CustomError('worker_unknown_request', `+${request.type}`);
    }
    return {
        type: constants_1.RESPONSES.UNSUBSCRIBE,
        payload: { subscribed: request.state.getAccounts().length > 0 },
    };
};
const onRequest = (request, isTestnet) => {
    switch (request.type) {
        case constants_1.MESSAGES.GET_ACCOUNT_INFO:
            return getAccountInfo(request);
        case constants_1.MESSAGES.GET_INFO:
            return getInfo(request, isTestnet);
        case constants_1.MESSAGES.PUSH_TRANSACTION:
            return pushTransaction(request);
        case constants_1.MESSAGES.ESTIMATE_FEE:
            return estimateFee(request);
        case constants_1.MESSAGES.SUBSCRIBE:
            return subscribe(request);
        case constants_1.MESSAGES.UNSUBSCRIBE:
            return unsubscribe(request);
        default:
            throw new errors_1.CustomError('worker_unknown_request', `+${request.type}`);
    }
};
class SolanaWorker extends baseWorker_1.BaseWorker {
    constructor() {
        super(...arguments);
        this.lazyTokens = (0, utils_1.createLazy)(() => blockchain_link_utils_1.solanaUtils.getTokenMetadata());
        this.isTestnet = false;
    }
    isConnected(api) {
        return !!api;
    }
    tryConnect(url) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const clusterUrl = (0, web3_js_1.mainnet)(url);
            const transport = (0, web3_js_1.createDefaultRpcTransport)({
                url: clusterUrl,
                headers: {
                    'User-Agent': `Trezor Suite ${(0, env_utils_1.getSuiteVersion)()}`,
                },
            });
            const api = {
                clusterUrl,
                rpc: (0, web3_js_1.createSolanaRpcFromTransport)(transport),
                rpcSubscriptions: (0, web3_js_1.createSolanaRpcSubscriptions)((0, web3_js_1.mainnet)(url.replace('http', 'ws'))),
            };
            this.isTestnet =
                (yield api.rpc.getGenesisHash().send()) !==
                    '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d';
            this.post({ id: -1, type: constants_1.RESPONSES.CONNECTED });
            return api;
        });
    }
    messageHandler(event) {
        const _super = Object.create(null, {
            messageHandler: { get: () => super.messageHandler }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (yield _super.messageHandler.call(this, event))
                    return true;
                const request = Object.assign(Object.assign({}, event.data), { connect: () => this.connect(), onNetworkDisconnect: () => {
                        if (this.api) {
                            this.post({
                                id: -1,
                                type: constants_1.RESPONSES.DISCONNECTED,
                                payload: true,
                            });
                        }
                        this.disconnect();
                    }, post: (data) => this.post(data), state: this.state, getTokenMetadata: this.lazyTokens.getOrInit });
                const response = yield onRequest(request, this.isTestnet);
                this.post(Object.assign({ id: event.data.id }, response));
            }
            catch (error) {
                this.errorResponse(event.data.id, error);
            }
        });
    }
    disconnect() {
        if (!this.api) {
            return;
        }
        this.state.getAccounts().forEach(a => {
            if (a.subscriptionId != null) {
                abortSubscription(a.subscriptionId);
            }
        });
        if (this.state.getSubscription('block')) {
            const interval = this.state.getSubscription('block');
            clearInterval(interval);
            this.state.removeSubscription('block');
        }
        this.api = undefined;
    }
}
function Solana() {
    return new SolanaWorker();
}
if (baseWorker_1.CONTEXT === 'worker') {
    const module = new SolanaWorker();
    onmessage = module.messageHandler.bind(module);
}
//# sourceMappingURL=index.js.map