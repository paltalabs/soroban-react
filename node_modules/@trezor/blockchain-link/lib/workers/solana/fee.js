"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPriorityFee = exports.getBaseFee = void 0;
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const bigNumber_1 = require("@trezor/utils/lib/bigNumber");
const COMPUTE_BUDGET_PROGRAM_ID = 'ComputeBudget111111111111111111111111111111';
const DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS = BigInt(300000);
const stripComputeBudgetInstructions = (message) => (Object.assign(Object.assign({}, message), { instructions: message.instructions.filter(instruction => message.staticAccounts[instruction.programAddressIndex] !== COMPUTE_BUDGET_PROGRAM_ID) }));
const getBaseFee = (api, message) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const messageWithoutComputeBudget = (0, web3_js_1.pipe)(stripComputeBudgetInstructions(message), (0, web3_js_1.getCompiledTransactionMessageEncoder)().encode, (0, web3_js_1.getBase64Decoder)().decode);
    const result = yield api.getFeeForMessage(messageWithoutComputeBudget).send();
    if (result.value == null) {
        throw new Error('Could not estimate fee for transaction.');
    }
    return result.value;
});
exports.getBaseFee = getBaseFee;
const getPriorityFee = (api, compiledMessage, signatures) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const message = (0, web3_js_1.decompileTransactionMessage)(compiledMessage);
    const affectedAccounts = new Set(message.instructions
        .flatMap(instruction => { var _a; return (_a = instruction.accounts) !== null && _a !== void 0 ? _a : []; })
        .filter(({ role }) => (0, web3_js_1.isWritableRole)(role))
        .map(({ address }) => address));
    const messageBytes = (0, web3_js_1.pipe)(compiledMessage, (0, web3_js_1.getCompiledTransactionMessageEncoder)().encode);
    const rawTx = (0, web3_js_1.pipe)({
        messageBytes,
        signatures,
    }, (0, web3_js_1.getTransactionEncoder)().encode, (0, web3_js_1.getBase64Decoder)().decode);
    const simulated = yield api
        .simulateTransaction(rawTx, { commitment: 'confirmed', encoding: 'base64' })
        .send();
    if (simulated.value.err != null || !simulated.value.unitsConsumed) {
        console.error('Could not simulate transaction:', simulated.value.err);
        throw new Error(`Could not simulate transaction: ${simulated.value.err}`);
    }
    const computeUnitLimit = new bigNumber_1.BigNumber(simulated.value.unitsConsumed.toString())
        .times(1.2)
        .decimalPlaces(0, bigNumber_1.BigNumber.ROUND_UP);
    const recentFees = yield api.getRecentPrioritizationFees(Array.from(affectedAccounts)).send();
    const networkPriorityFee = recentFees
        .map(a => a.prioritizationFee)
        .sort((a, b) => Number(b - a))[Math.floor(recentFees.length / 4)];
    const computeUnitPrice = networkPriorityFee > DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS
        ? networkPriorityFee
        : DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS;
    const fee = new bigNumber_1.BigNumber(computeUnitPrice.toString())
        .times(Math.pow(10, -6))
        .times(computeUnitLimit)
        .decimalPlaces(0, bigNumber_1.BigNumber.ROUND_UP)
        .toString(10);
    return {
        computeUnitPrice: computeUnitPrice.toString(10),
        computeUnitLimit: computeUnitLimit.toString(10),
        fee,
    };
});
exports.getPriorityFee = getPriorityFee;
//# sourceMappingURL=fee.js.map