"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Ripple;
const tslib_1 = require("tslib");
const ripple_lib_1 = require("ripple-lib");
const errors_1 = require("ripple-lib/dist/npm/common/errors");
const bigNumber_1 = require("@trezor/utils/lib/bigNumber");
const errors_2 = require("@trezor/blockchain-link-types/lib/constants/errors");
const constants_1 = require("@trezor/blockchain-link-types/lib/constants");
const utils = tslib_1.__importStar(require("@trezor/blockchain-link-utils/lib/ripple"));
const baseWorker_1 = require("../baseWorker");
const DEFAULT_TIMEOUT = 20 * 1000;
const DEFAULT_PING_TIMEOUT = 3 * 60 * 1000;
const RESERVE = {
    BASE: '10000000',
    OWNER: '2000000',
};
const transformError = (error) => {
    if (error instanceof errors_1.RippleError) {
        const code = error.name === 'TimeoutError' ? 'websocket_timeout' : 'websocket_error_message';
        if (error.data) {
            return new errors_2.CustomError(code, `${error.name} ${error.data.error_message}`);
        }
        return new errors_2.CustomError(code, error.toString());
    }
    return error;
};
const getInfo = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const api = yield request.connect();
    const info = yield api.getServerInfo();
    RESERVE.BASE = api.xrpToDrops(info.validatedLedger.reserveBaseXRP);
    RESERVE.OWNER = api.xrpToDrops(info.validatedLedger.reserveIncrementXRP);
    return {
        type: constants_1.RESPONSES.GET_INFO,
        payload: Object.assign({ url: api.connection.getUrl() }, utils.transformServerInfo(info)),
    };
});
const getMempoolAccountInfo = (api, account) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const info = yield api.request('account_info', {
        account,
        ledger_index: 'current',
        queue: true,
    });
    return {
        xrpBalance: info.account_data.Balance,
        sequence: info.account_data.Sequence,
        txs: info.queue_data ? info.queue_data.txn_count : 0,
    };
});
const getAccountInfo = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { payload } = request;
    const account = {
        descriptor: payload.descriptor,
        balance: '0',
        availableBalance: '0',
        empty: true,
        history: {
            total: -1,
            unconfirmed: 0,
            transactions: undefined,
        },
        misc: {
            sequence: 0,
            reserve: RESERVE.BASE,
        },
    };
    try {
        const api = yield request.connect();
        const info = yield api.getAccountInfo(payload.descriptor);
        const ownersReserve = info.ownerCount > 0
            ? new bigNumber_1.BigNumber(info.ownerCount).times(RESERVE.OWNER).toString()
            : '0';
        const reserve = new bigNumber_1.BigNumber(RESERVE.BASE).plus(ownersReserve).toString();
        const misc = {
            sequence: info.sequence,
            reserve,
        };
        account.misc = misc;
        account.balance = api.xrpToDrops(info.xrpBalance);
        account.availableBalance = new bigNumber_1.BigNumber(account.balance).minus(reserve).toString();
        account.empty = false;
    }
    catch (error) {
        if (error instanceof errors_1.RippleError && error.data && error.data.error === 'actNotFound') {
            return {
                type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
                payload: account,
            };
        }
        throw error;
    }
    try {
        const api = yield request.connect();
        const mempoolInfo = yield getMempoolAccountInfo(api, payload.descriptor);
        const { misc } = account;
        const reserve = misc && typeof misc.reserve === 'string' ? misc.reserve : RESERVE.BASE;
        account.availableBalance = new bigNumber_1.BigNumber(mempoolInfo.xrpBalance).minus(reserve).toString();
        account.misc.sequence = mempoolInfo.sequence;
        account.history.unconfirmed = mempoolInfo.txs;
    }
    catch (_a) {
    }
    if (payload.details !== 'txs') {
        return {
            type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
            payload: account,
        };
    }
    const requestOptions = {
        account: payload.descriptor,
        ledger_index_min: payload.from ? payload.from : undefined,
        ledger_index_max: payload.to ? payload.to : undefined,
        limit: payload.pageSize || 25,
        marker: payload.marker,
    };
    const api = yield request.connect();
    const transactionsData = yield api.request('account_tx', requestOptions);
    account.history.transactions = transactionsData.transactions.map(raw => utils.transformTransaction(raw.tx, payload.descriptor));
    return {
        type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
        payload: Object.assign(Object.assign({}, account), { marker: transactionsData.marker }),
    };
});
const getTransaction = (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ connect, payload }) {
    const api = yield connect();
    const rawtx = yield api.request('tx', { transaction: payload, binary: false });
    const tx = utils.transformTransaction(rawtx);
    return {
        type: constants_1.RESPONSES.GET_TRANSACTION,
        payload: tx,
    };
});
const pushTransaction = (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ connect, payload }) {
    const api = yield connect();
    const info = yield api.submit(payload.toUpperCase());
    if (info.resultCode === 'tesSUCCESS') {
        return {
            type: constants_1.RESPONSES.PUSH_TRANSACTION,
            payload: info.tx_json.hash,
        };
    }
    throw new Error(info.resultMessage);
});
const estimateFee = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const api = yield request.connect();
    const fee = yield api.getFee();
    let drops = api.xrpToDrops(fee);
    if (new bigNumber_1.BigNumber(drops).gt('2000')) {
        drops = '12';
    }
    const payload = request.payload && Array.isArray(request.payload.blocks)
        ? request.payload.blocks.map(() => ({ feePerUnit: drops }))
        : [{ feePerUnit: drops }];
    return {
        type: constants_1.RESPONSES.ESTIMATE_FEE,
        payload,
    };
});
const onNewBlock = ({ post }, event) => {
    post({
        id: -1,
        type: constants_1.RESPONSES.NOTIFICATION,
        payload: {
            type: 'block',
            payload: {
                blockHeight: event.ledgerVersion,
                blockHash: event.ledgerHash,
            },
        },
    });
};
const onTransaction = ({ state, post }, event) => {
    if (event.type !== 'transaction')
        return;
    const tx = event.transaction;
    if (event.transaction.TransactionType !== 'Payment')
        return;
    const notify = (descriptor) => {
        post({
            id: -1,
            type: constants_1.RESPONSES.NOTIFICATION,
            payload: {
                type: 'notification',
                payload: {
                    descriptor,
                    tx: utils.transformTransaction(Object.assign(Object.assign({}, event), tx), descriptor),
                },
            },
        });
    };
    const subscribed = state.getAddresses();
    const sent = subscribed.find(a => a === tx.Account);
    if (sent)
        notify(sent);
    const recv = subscribed.find(a => a === tx.Destination);
    if (recv)
        notify(recv);
};
const subscribeAccounts = (ctx, accounts) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const api = yield ctx.connect();
    const { state } = ctx;
    const prevAddresses = state.getAddresses();
    state.addAccounts(accounts);
    const uniqueAddresses = state.getAddresses().filter(a => prevAddresses.indexOf(a) < 0);
    if (uniqueAddresses.length > 0) {
        if (!state.getSubscription('notification')) {
            api.connection.on('transaction', ev => onTransaction(ctx, ev));
            state.addSubscription('notification');
        }
        yield api.request('subscribe', {
            accounts_proposed: uniqueAddresses,
        });
    }
    return { subscribed: state.getAddresses().length > 0 };
});
const subscribeAddresses = (ctx, addresses) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const api = yield ctx.connect();
    const { state } = ctx;
    const uniqueAddresses = state.addAddresses(addresses);
    if (uniqueAddresses.length > 0) {
        if (!state.getSubscription('transaction')) {
            api.connection.on('transaction', ev => onTransaction(ctx, ev));
            state.addSubscription('transaction');
        }
        const request = {
            accounts_proposed: uniqueAddresses,
        };
        yield api.request('subscribe', request);
    }
    return { subscribed: state.getAddresses().length > 0 };
});
const subscribeBlock = (ctx) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!ctx.state.getSubscription('ledger')) {
        const api = yield ctx.connect();
        api.on('ledger', ev => onNewBlock(ctx, ev));
        ctx.state.addSubscription('ledger');
    }
    return { subscribed: true };
});
const subscribe = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { payload } = request;
    let response;
    if (payload.type === 'accounts') {
        response = yield subscribeAccounts(request, payload.accounts);
    }
    else if (payload.type === 'addresses') {
        response = yield subscribeAddresses(request, payload.addresses);
    }
    else if (payload.type === 'block') {
        response = yield subscribeBlock(request);
    }
    else {
        throw new errors_2.CustomError('invalid_param', '+type');
    }
    return {
        type: constants_1.RESPONSES.SUBSCRIBE,
        payload: response,
    };
});
const unsubscribeAddresses = (_a, addresses_1) => tslib_1.__awaiter(void 0, [_a, addresses_1], void 0, function* ({ state, connect }, addresses) {
    const api = yield connect();
    if (!addresses) {
        const all = state.getAddresses();
        state.removeAccounts(state.getAccounts());
        state.removeAddresses(all);
        yield api.request('unsubscribe', {
            accounts_proposed: all,
        });
    }
    else {
        state.removeAddresses(addresses);
        yield api.request('unsubscribe', {
            accounts_proposed: addresses,
        });
    }
    if (state.getAccounts().length < 1) {
        api.connection.removeAllListeners('transaction');
        state.removeSubscription('transaction');
    }
});
const unsubscribeAccounts = (ctx, accounts) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { state } = ctx;
    const prevAddresses = state.getAddresses();
    state.removeAccounts(accounts || state.getAccounts());
    const addresses = state.getAddresses();
    const uniqueAddresses = prevAddresses.filter(a => addresses.indexOf(a) < 0);
    yield unsubscribeAddresses(ctx, uniqueAddresses);
});
const unsubscribeBlock = (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ state, connect }) {
    if (!state.getSubscription('ledger'))
        return;
    const api = yield connect();
    api.removeAllListeners('ledger');
    state.removeSubscription('ledger');
});
const unsubscribe = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { payload } = request;
    if (payload.type === 'accounts') {
        yield unsubscribeAccounts(request, payload.accounts);
    }
    else if (payload.type === 'addresses') {
        yield unsubscribeAddresses(request, payload.addresses);
    }
    else if (payload.type === 'block') {
        yield unsubscribeBlock(request);
    }
    return {
        type: constants_1.RESPONSES.UNSUBSCRIBE,
        payload: { subscribed: request.state.getAddresses().length > 0 },
    };
});
const onRequest = (request) => {
    switch (request.type) {
        case constants_1.MESSAGES.GET_INFO:
            return getInfo(request);
        case constants_1.MESSAGES.GET_ACCOUNT_INFO:
            return getAccountInfo(request);
        case constants_1.MESSAGES.GET_TRANSACTION:
            return getTransaction(request);
        case constants_1.MESSAGES.ESTIMATE_FEE:
            return estimateFee(request);
        case constants_1.MESSAGES.PUSH_TRANSACTION:
            return pushTransaction(request);
        case constants_1.MESSAGES.SUBSCRIBE:
            return subscribe(request);
        case constants_1.MESSAGES.UNSUBSCRIBE:
            return unsubscribe(request);
        default:
            throw new errors_2.CustomError('worker_unknown_request', `+${request.type}`);
    }
};
class RippleWorker extends baseWorker_1.BaseWorker {
    cleanup() {
        if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
        }
        if (this.api) {
            this.api.removeAllListeners();
        }
        super.cleanup();
    }
    isConnected(api) {
        var _a;
        return (_a = api === null || api === void 0 ? void 0 : api.isConnected()) !== null && _a !== void 0 ? _a : false;
    }
    tryConnect(url) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const options = {
                server: url,
                timeout: this.settings.timeout || DEFAULT_TIMEOUT,
                connectionTimeout: this.settings.timeout || DEFAULT_TIMEOUT,
            };
            if (ripple_lib_1.RippleAPI._ALLOW_AGENT) {
                options.agent = this.proxyAgent;
            }
            const api = new ripple_lib_1.RippleAPI(options);
            api.connection.reconnect = () => new Promise(() => { });
            yield api.connect();
            api.on('ledger', ledger => {
                RESERVE.BASE = api.xrpToDrops(ledger.reserveBaseXRP);
                RESERVE.OWNER = api.xrpToDrops(ledger.reserveIncrementXRP);
            });
            api.on('disconnected', () => {
                this.post({ id: -1, type: constants_1.RESPONSES.DISCONNECTED, payload: true });
                this.cleanup();
            });
            this.post({ id: -1, type: constants_1.RESPONSES.CONNECTED });
            return api;
        });
    }
    disconnect() {
        if (this.api) {
            this.api.disconnect();
        }
    }
    messageHandler(event) {
        const _super = Object.create(null, {
            messageHandler: { get: () => super.messageHandler }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (yield _super.messageHandler.call(this, event))
                    return true;
                const request = Object.assign(Object.assign({}, event.data), { connect: () => this.connect(), post: (data) => this.post(data), state: this.state });
                const response = yield onRequest(request);
                this.post(Object.assign({ id: event.data.id }, response));
            }
            catch (error) {
                this.errorResponse(event.data.id, transformError(error));
            }
            finally {
                if (event.data.type !== constants_1.MESSAGES.DISCONNECT) {
                    this.setPingTimeout();
                }
            }
        });
    }
    setPingTimeout() {
        if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
        }
        this.pingTimeout = setTimeout(() => this.onPing(), this.settings.pingTimeout || DEFAULT_PING_TIMEOUT);
    }
    onPing() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.api || !this.api.isConnected())
                return;
            if (this.state.hasSubscriptions() || this.settings.keepAlive) {
                try {
                    yield this.api.getServerInfo();
                }
                catch (error) {
                    this.debug(`Error in timeout ping request: ${error}`);
                }
                this.setPingTimeout();
            }
            else {
                this.api.disconnect();
            }
        });
    }
}
function Ripple() {
    return new RippleWorker();
}
if (baseWorker_1.CONTEXT === 'worker') {
    const module = new RippleWorker();
    onmessage = module.messageHandler.bind(module);
}
//# sourceMappingURL=index.js.map