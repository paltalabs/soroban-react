"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTransaction = exports.getTokens = exports.getAmount = exports.getDetails = exports.getTxType = exports.getTargets = exports.extractAccountBalanceDiff = exports.transformTokenInfo = exports.getTokenNameAndSymbol = exports.getTokenMetadata = exports.WSOL_MINT = exports.SYSTEM_PROGRAM_PUBLIC_KEY = exports.ASSOCIATED_TOKEN_PROGRAM_PUBLIC_KEY = exports.TOKEN_PROGRAM_PUBLIC_KEY = void 0;
exports.getNativeEffects = getNativeEffects;
const tslib_1 = require("tslib");
const ts_belt_1 = require("@mobily/ts-belt");
const bigNumber_1 = require("@trezor/utils/lib/bigNumber");
const utils_1 = require("@trezor/utils");
const env_utils_1 = require("@trezor/env-utils");
const utils_2 = require("./utils");
exports.TOKEN_PROGRAM_PUBLIC_KEY = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
exports.ASSOCIATED_TOKEN_PROGRAM_PUBLIC_KEY = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL';
exports.SYSTEM_PROGRAM_PUBLIC_KEY = '11111111111111111111111111111111';
exports.WSOL_MINT = 'So11111111111111111111111111111111111111112';
const getTokenMetadata = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const env = (0, env_utils_1.isCodesignBuild)() ? 'stable' : 'develop';
    const response = yield fetch(`https://data.trezor.io/suite/definitions/${env}/solana.advanced.coin.definitions.v1.json`);
    if (!response.ok) {
        throw Error(response.statusText);
    }
    const data = yield response.json();
    data[exports.WSOL_MINT] = { symbol: 'wSOL', name: 'Wrapped SOL' };
    return data;
});
exports.getTokenMetadata = getTokenMetadata;
const getTokenNameAndSymbol = (mint, tokenDetailByMint) => {
    const tokenDetail = tokenDetailByMint[mint];
    return tokenDetail
        ? { name: tokenDetail.name, symbol: tokenDetail.symbol }
        : {
            name: mint,
            symbol: (0, utils_2.formatTokenSymbol)(mint),
        };
};
exports.getTokenNameAndSymbol = getTokenNameAndSymbol;
const isSplTokenAccount = (tokenAccount) => {
    const { parsed } = tokenAccount.account.data;
    return (tokenAccount.account.data.program === 'spl-token' &&
        'info' in parsed &&
        !!parsed.info &&
        'mint' in parsed.info &&
        typeof parsed.info.mint === 'string' &&
        'tokenAmount' in parsed.info &&
        !!parsed.info.tokenAmount &&
        typeof parsed.info.tokenAmount === 'object' &&
        'amount' in parsed.info.tokenAmount &&
        typeof parsed.info.tokenAmount.amount === 'string' &&
        'decimals' in parsed.info.tokenAmount &&
        typeof parsed.info.tokenAmount.decimals === 'number');
};
const transformTokenInfo = (tokenAccounts, tokenDetailByMint) => {
    const tokens = ts_belt_1.F.toMutable((0, ts_belt_1.pipe)(tokenAccounts, ts_belt_1.A.filter(isSplTokenAccount), ts_belt_1.A.map(tokenAccount => {
        const { info } = tokenAccount.account.data.parsed;
        return Object.assign(Object.assign({ type: 'SPL', contract: info.mint, balance: info.tokenAmount.amount, decimals: info.tokenAmount.decimals }, (0, exports.getTokenNameAndSymbol)(info.mint, tokenDetailByMint)), { address: tokenAccount.pubkey });
    }), ts_belt_1.A.reduce({}, (acc, token) => {
        if (acc[token.contract] != null) {
            acc[token.contract].balance = new bigNumber_1.BigNumber(acc[token.contract].balance || '0')
                .plus(token.balance || '0')
                .toString();
            acc[token.contract].accounts.push({
                publicKey: token.address,
                balance: token.balance || '0',
            });
        }
        else {
            const { type, contract, balance, decimals, name, symbol } = token;
            acc[token.contract] = {
                type,
                contract,
                balance,
                decimals,
                name,
                symbol,
                accounts: [{ publicKey: token.address, balance: balance || '0' }],
            };
        }
        return acc;
    }), ts_belt_1.D.values));
    return tokens;
};
exports.transformTokenInfo = transformTokenInfo;
const extractAccountBalanceDiff = (transaction, address, isTokenDiff = false) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const pubKeyIndex = transaction.transaction.message.accountKeys.findIndex(ak => ak.pubkey === address);
    if (pubKeyIndex === -1) {
        return null;
    }
    if (isTokenDiff) {
        const preBalance = (_c = (_b = (_a = transaction.meta) === null || _a === void 0 ? void 0 : _a.preTokenBalances) === null || _b === void 0 ? void 0 : _b.find(balance => balance.accountIndex === pubKeyIndex)) === null || _c === void 0 ? void 0 : _c.uiTokenAmount.amount;
        const postBalance = (_f = (_e = (_d = transaction.meta) === null || _d === void 0 ? void 0 : _d.postTokenBalances) === null || _e === void 0 ? void 0 : _e.find(balance => balance.accountIndex === pubKeyIndex)) === null || _f === void 0 ? void 0 : _f.uiTokenAmount.amount;
        return {
            preBalance: new bigNumber_1.BigNumber(preBalance !== null && preBalance !== void 0 ? preBalance : 0),
            postBalance: new bigNumber_1.BigNumber(postBalance !== null && postBalance !== void 0 ? postBalance : 0),
        };
    }
    const preBalance = (_g = transaction.meta) === null || _g === void 0 ? void 0 : _g.preBalances[pubKeyIndex];
    const postBalance = (_h = transaction.meta) === null || _h === void 0 ? void 0 : _h.postBalances[pubKeyIndex];
    return {
        preBalance: new bigNumber_1.BigNumber((_j = preBalance === null || preBalance === void 0 ? void 0 : preBalance.toString(10)) !== null && _j !== void 0 ? _j : 0),
        postBalance: new bigNumber_1.BigNumber((_k = postBalance === null || postBalance === void 0 ? void 0 : postBalance.toString(10)) !== null && _k !== void 0 ? _k : 0),
    };
};
exports.extractAccountBalanceDiff = extractAccountBalanceDiff;
const isWSolTransfer = (ixs) => ixs.find(ix => 'parsed' in ix &&
    !!ix.parsed.info &&
    'mint' in ix.parsed.info &&
    ix.parsed.info.mint === exports.WSOL_MINT);
function getNativeEffects(transaction) {
    const wSolTransferInstruction = isWSolTransfer(transaction.transaction.message.instructions || []);
    return transaction.transaction.message.accountKeys
        .map(ak => {
        const targetAddress = ak.pubkey;
        const balanceDiff = (0, exports.extractAccountBalanceDiff)(transaction, targetAddress);
        if (wSolTransferInstruction && 'parsed' in wSolTransferInstruction) {
            if ((!!wSolTransferInstruction.parsed.info &&
                'destination' in wSolTransferInstruction.parsed.info &&
                wSolTransferInstruction.parsed.info.destination === targetAddress) ||
                (!!wSolTransferInstruction.parsed.info &&
                    'source' in wSolTransferInstruction.parsed.info &&
                    wSolTransferInstruction.parsed.info.source === targetAddress)) {
                return null;
            }
        }
        if (!balanceDiff) {
            return null;
        }
        return {
            address: targetAddress,
            amount: balanceDiff.postBalance.minus(balanceDiff.preBalance),
        };
    })
        .filter((effect) => !!effect)
        .filter(({ amount }) => !amount.isZero());
}
const getTargets = (effects, txType, accountAddress) => effects
    .filter(effect => {
    if (txType === 'self') {
        return false;
    }
    if (txType === 'unknown') {
        return false;
    }
    if (txType !== 'sent' && effect.address !== accountAddress) {
        return false;
    }
    return effect.amount.isGreaterThan(0);
})
    .map((effect, i) => {
    const target = {
        n: i,
        addresses: [effect.address],
        isAddress: true,
        amount: effect.amount.abs().toString(),
        isAccountTarget: effect.address === accountAddress && txType !== 'sent',
    };
    return target;
});
exports.getTargets = getTargets;
const getTokenTransferTxType = (transfers) => {
    if (transfers.some(transfer => transfer.to === transfer.from)) {
        return 'self';
    }
    if (transfers.some(({ type }) => type === 'recv')) {
        return 'recv';
    }
    if (transfers.some(({ type }) => type === 'sent')) {
        return 'sent';
    }
    return 'unknown';
};
const getNativeTransferTxType = (effects, accountAddress, transaction) => {
    var _a, _b, _c;
    if (effects.length === 1 &&
        ((_a = effects[0]) === null || _a === void 0 ? void 0 : _a.address) === accountAddress &&
        ((_b = effects[0]) === null || _b === void 0 ? void 0 : _b.amount.abs().isEqualTo(new bigNumber_1.BigNumber(((_c = transaction.meta) === null || _c === void 0 ? void 0 : _c.fee.toString()) || 0)))) {
        return 'self';
    }
    const [senders, receivers] = (0, utils_1.arrayPartition)(effects, ({ amount }) => amount.isNegative());
    if (senders.some(({ address }) => address === accountAddress)) {
        return 'sent';
    }
    if (receivers.some(({ address }) => address === accountAddress)) {
        return 'recv';
    }
    return 'unknown';
};
const getTxType = (transaction, effects, accountAddress, tokenTransfers) => {
    var _a;
    if ((_a = transaction.meta) === null || _a === void 0 ? void 0 : _a.err) {
        return 'failed';
    }
    const parsedInstructions = transaction.transaction.message.instructions.filter((instruction) => 'parsed' in instruction);
    if (parsedInstructions.length === 0) {
        return 'unknown';
    }
    const isInstructionCreatingTokenAccount = (instruction) => instruction.program === 'spl-associated-token-account' &&
        (instruction.parsed.type === 'create' || instruction.parsed.type === 'createIdempotent');
    const isTransfer = parsedInstructions.every(instruction => instruction.parsed.type === 'transfer' ||
        instruction.parsed.type === 'transferChecked' ||
        (instruction.program === 'system' && instruction.parsed.type === 'advanceNonce') ||
        isInstructionCreatingTokenAccount(instruction));
    if (isTransfer) {
        return tokenTransfers.length > 0
            ? getTokenTransferTxType(tokenTransfers)
            : getNativeTransferTxType(effects, accountAddress, transaction);
    }
    return 'unknown';
};
exports.getTxType = getTxType;
const getDetails = (transaction, effects, accountAddress, txType) => {
    var _a, _b;
    const senders = effects.filter(({ amount }) => amount.isNegative());
    const receivers = effects
        .filter(({ amount, address }) => amount.isPositive() && (txType !== 'sent' ? address === accountAddress : true))
        .filter(({ address }) => !(txType === 'self' && address === accountAddress));
    const getVin = ({ address, amount }, i) => {
        var _a;
        return ({
            txid: transaction.transaction.signatures[0].toString(),
            version: (_a = transaction.version) === null || _a === void 0 ? void 0 : _a.toString(),
            isAddress: true,
            isAccountOwned: address === accountAddress,
            n: i,
            value: amount === null || amount === void 0 ? void 0 : amount.abs().toString(),
            addresses: [address],
        });
    };
    const vin = senders.map((sender, i) => getVin(sender, i));
    const vout = receivers.map((receiver, i) => getVin(receiver, i));
    if (txType === 'self') {
        vout.push(getVin({ address: accountAddress }, vout.length));
    }
    return {
        size: ((_a = transaction.meta) === null || _a === void 0 ? void 0 : _a.computeUnitsConsumed) != null
            ? Number((_b = transaction.meta) === null || _b === void 0 ? void 0 : _b.computeUnitsConsumed)
            : 0,
        totalInput: senders
            .reduce((acc, curr) => acc.plus(curr.amount.abs()), new bigNumber_1.BigNumber(0))
            .toString(),
        totalOutput: receivers
            .reduce((acc, curr) => acc.plus(curr.amount.abs()), new bigNumber_1.BigNumber(0))
            .toString(),
        vin,
        vout,
    };
};
exports.getDetails = getDetails;
const getAmount = (accountEffect, txType) => {
    if (!accountEffect) {
        return '0';
    }
    if (txType === 'self') {
        return '0';
    }
    return accountEffect.amount.abs().toString();
};
exports.getAmount = getAmount;
const isTokenTransferInstruction = (ix) => {
    if (!('parsed' in ix)) {
        return false;
    }
    const { parsed } = ix;
    return ('program' in ix &&
        typeof ix.program === 'string' &&
        ix.program === 'spl-token' &&
        'type' in parsed &&
        typeof parsed.type === 'string' &&
        (parsed.type === 'transferChecked' || parsed.type === 'transfer') &&
        'info' in parsed &&
        typeof parsed.info === 'object' &&
        (('authority' in parsed.info && typeof parsed.info.authority === 'string') ||
            ('multisigAuthority' in parsed.info &&
                typeof parsed.info.multisigAuthority === 'string')) &&
        'source' in parsed.info &&
        typeof parsed.info.source === 'string' &&
        'destination' in parsed.info &&
        typeof parsed.info.destination === 'string' &&
        (('tokenAmount' in parsed.info &&
            !!parsed.info.tokenAmount &&
            typeof parsed.info.tokenAmount === 'object' &&
            'amount' in parsed.info.tokenAmount &&
            typeof parsed.info.tokenAmount.amount === 'string') ||
            ('amount' in parsed.info && typeof parsed.info.amount === 'string')));
};
const getTokens = (tx, accountAddress, tokenDetailByMint, tokenAccountsInfos) => {
    const getUiType = ({ parsed }) => {
        const accountAddresses = [
            ...tokenAccountsInfos.map(({ address }) => address),
            accountAddress,
        ];
        const isAccountDestination = accountAddresses.includes(parsed.info.destination);
        const isAccountSource = accountAddresses.includes(parsed.info.multisigAuthority || parsed.info.authority || parsed.info.source);
        if (isAccountDestination && isAccountSource) {
            return 'self';
        }
        if (isAccountDestination) {
            return 'recv';
        }
        return 'sent';
    };
    const matchTokenAccountInfo = ({ parsed }, address) => {
        var _a, _b;
        return address === ((_a = parsed.info) === null || _a === void 0 ? void 0 : _a.source) ||
            address === parsed.info.destination ||
            address === ((_b = parsed.info) === null || _b === void 0 ? void 0 : _b.authority);
    };
    const effects = tx.transaction.message.instructions
        .filter(isTokenTransferInstruction)
        .map((ix) => {
        var _a, _b;
        const { parsed } = ix;
        const instructionTokenInfo = tokenAccountsInfos.find(tokenAccountInfo => matchTokenAccountInfo(ix, tokenAccountInfo.address));
        const mint = parsed.info.mint || (instructionTokenInfo === null || instructionTokenInfo === void 0 ? void 0 : instructionTokenInfo.mint) || 'Unknown token contract';
        const decimals = Number(((_a = parsed.info.tokenAmount) === null || _a === void 0 ? void 0 : _a.decimals) || (instructionTokenInfo === null || instructionTokenInfo === void 0 ? void 0 : instructionTokenInfo.decimals) || 0);
        const amount = ((_b = parsed.info.tokenAmount) === null || _b === void 0 ? void 0 : _b.amount) || parsed.info.amount || '-1';
        const source = parsed.info.authority || parsed.info.source;
        const from = source === (instructionTokenInfo === null || instructionTokenInfo === void 0 ? void 0 : instructionTokenInfo.address) ? accountAddress : source;
        const to = parsed.info.destination === (instructionTokenInfo === null || instructionTokenInfo === void 0 ? void 0 : instructionTokenInfo.address)
            ? accountAddress
            : parsed.info.destination;
        return Object.assign(Object.assign({ type: getUiType(ix), standard: 'SPL', from,
            to, contract: mint, decimals }, (0, exports.getTokenNameAndSymbol)(mint, tokenDetailByMint)), { amount });
    })
        .filter(effect => effect.to === accountAddress || effect.from === accountAddress);
    return effects;
};
exports.getTokens = getTokens;
const transformTransaction = (tx, accountAddress, tokenAccountsInfos, tokenDetailByMint = {}) => {
    const nativeEffects = getNativeEffects(tx);
    const tokens = (0, exports.getTokens)(tx, accountAddress, tokenDetailByMint, tokenAccountsInfos);
    const type = (0, exports.getTxType)(tx, nativeEffects, accountAddress, tokens);
    const targets = (0, exports.getTargets)(nativeEffects, type, accountAddress);
    const amount = (0, exports.getAmount)(nativeEffects.find(({ address }) => address === accountAddress), type);
    const details = (0, exports.getDetails)(tx, nativeEffects, accountAddress, type);
    return {
        type,
        txid: tx.transaction.signatures[0].toString(),
        blockTime: tx.blockTime == null ? undefined : Number(tx.blockTime),
        amount,
        fee: tx.meta.fee.toString(),
        targets,
        tokens,
        internalTransfers: [],
        details,
        blockHash: tx.transaction.message.recentBlockhash,
        solanaSpecific: {
            status: 'confirmed',
        },
    };
};
exports.transformTransaction = transformTransaction;
//# sourceMappingURL=solana.js.map