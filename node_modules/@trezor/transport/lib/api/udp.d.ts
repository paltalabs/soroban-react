import UDP from 'dgram';
import { AbstractApi, AbstractApiConstructorParams, DEVICE_TYPE } from './abstract';
import { DescriptorApiLevel, PathInternal } from '../types';
export declare class UdpApi extends AbstractApi {
    chunkSize: number;
    protected devices: DescriptorApiLevel[];
    private listenAbortController;
    protected interface: UDP.Socket;
    protected communicating: boolean;
    private debugLink?;
    constructor({ logger, debugLink }: AbstractApiConstructorParams & {
        debugLink?: boolean;
    });
    listen(): void;
    private listenLoop;
    write(path: string, buffer: Buffer, signal?: AbortSignal): Promise<import("../types").Success<undefined> | import("../types").ErrorGeneric<"Unable to open device" | "A transfer error has occurred." | "device not found" | "device disconnected during action" | "unexpected error" | "Aborted by signal">>;
    read(_path: string, signal?: AbortSignal): Promise<import("../types").Success<Buffer> | import("../types").ErrorGeneric<"Unable to open device" | "A transfer error has occurred." | "device not found" | "device disconnected during action" | "unexpected error" | "Aborted by signal" | "Aborted by timeout">>;
    private ping;
    enumerate(signal?: AbortSignal): Promise<import("../types").Success<{
        path: PathInternal;
        type: DEVICE_TYPE;
        product: number;
        vendor: number;
    }[]> | {
        success: false;
        error: "Aborted by signal";
        message: string | undefined;
    }>;
    private handleDevicesChange;
    openDevice(_path: string, _first: boolean, _signal?: AbortSignal): Promise<import("../types").Success<undefined>>;
    closeDevice(_path: string): Promise<import("../types").Success<undefined>>;
    dispose(): void;
}
//# sourceMappingURL=udp.d.ts.map