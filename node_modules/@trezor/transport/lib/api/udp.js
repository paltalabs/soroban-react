"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UdpApi = void 0;
const tslib_1 = require("tslib");
const dgram_1 = tslib_1.__importDefault(require("dgram"));
const utils_1 = require("@trezor/utils");
const abstract_1 = require("./abstract");
const types_1 = require("../types");
const ERRORS = tslib_1.__importStar(require("../errors"));
class UdpApi extends abstract_1.AbstractApi {
    constructor({ logger, debugLink }) {
        super({ logger });
        this.chunkSize = 64;
        this.devices = [];
        this.listenAbortController = new AbortController();
        this.interface = dgram_1.default.createSocket({
            type: 'udp4',
            signal: this.listenAbortController.signal,
        });
        this.communicating = false;
        this.debugLink = debugLink;
    }
    listen() {
        if (this.listening)
            return;
        this.listening = true;
        this.listenLoop();
    }
    listenLoop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            while (this.listening) {
                yield (0, utils_1.createTimeoutPromise)(500);
                if (!this.listening)
                    break;
                yield this.enumerate(this.listenAbortController.signal);
            }
        });
    }
    write(path, buffer, signal) {
        const [hostname, port] = path.split(':');
        return new Promise(resolve => {
            const listener = () => {
                resolve(this.error({
                    error: ERRORS.ABORTED_BY_SIGNAL,
                }));
            };
            signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', listener);
            this.interface.send(buffer, Number.parseInt(port, 10), hostname, err => {
                var _a;
                signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', listener);
                if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                    return;
                }
                if (err) {
                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(err.message);
                    resolve(this.error({
                        error: ERRORS.INTERFACE_DATA_TRANSFER,
                        message: err.message,
                    }));
                }
                resolve(this.success(undefined));
            });
        });
    }
    read(_path, signal) {
        this.communicating = true;
        return new Promise(resolve => {
            const onClear = () => {
                this.interface.removeListener('error', onError);
                this.interface.removeListener('message', onMessage);
                signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', onAbort);
            };
            const onError = (err) => {
                var _a;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(err.message);
                resolve(this.error({
                    error: ERRORS.INTERFACE_DATA_TRANSFER,
                    message: err.message,
                }));
                onClear();
            };
            const onMessage = (message, _info) => {
                if (message.toString() === 'PONGPONG') {
                    return;
                }
                onClear();
                resolve(this.success(message));
            };
            const onAbort = () => {
                onClear();
                return resolve(this.error({
                    error: ERRORS.ABORTED_BY_SIGNAL,
                }));
            };
            signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', onAbort);
            this.interface.addListener('error', onError);
            this.interface.addListener('message', onMessage);
        }).finally(() => {
            this.communicating = false;
        });
    }
    ping(path, signal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.write(path, Buffer.from('PINGPING'), signal);
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error(ERRORS.ABORTED_BY_SIGNAL);
            }
            const pinged = new Promise(resolve => {
                const onClear = () => {
                    this.interface.removeListener('error', onError);
                    this.interface.removeListener('message', onMessage);
                    clearTimeout(timeout);
                    signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', onError);
                };
                const onError = () => {
                    resolve(false);
                    onClear();
                };
                const onMessage = (message, _info) => {
                    if (message.toString() === 'PONGPONG') {
                        resolve(true);
                        onClear();
                    }
                };
                signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', onError);
                this.interface.addListener('error', onError);
                this.interface.addListener('message', onMessage);
                const timeout = setTimeout(onError, this.communicating ? 10000 : 500);
            });
            return pinged;
        });
    }
    enumerate(signal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const paths = this.debugLink
                ? [(0, types_1.PathInternal)('127.0.0.1:21325')]
                : [(0, types_1.PathInternal)('127.0.0.1:21324')];
            try {
                const enumerateResult = yield Promise.all(paths.map(path => this.ping(path, signal).then(pinged => pinged
                    ? { path, type: abstract_1.DEVICE_TYPE.TypeEmulator, product: 0, vendor: 0 }
                    : undefined))).then(res => res.filter(utils_1.isNotUndefined));
                this.handleDevicesChange(enumerateResult);
                return this.success(enumerateResult);
            }
            catch (_a) {
                this.handleDevicesChange([]);
                return this.error({ error: ERRORS.ABORTED_BY_SIGNAL });
            }
        });
    }
    handleDevicesChange(devices) {
        const [known, unknown] = (0, utils_1.arrayPartition)(devices, device => !!this.devices.find(d => d.path === device.path));
        if (known.length !== this.devices.length || unknown.length > 0) {
            this.devices = devices;
            if (this.listening) {
                this.emit('transport-interface-change', this.devices);
            }
        }
    }
    openDevice(_path, _first, _signal) {
        return Promise.resolve(this.success(undefined));
    }
    closeDevice(_path) {
        return Promise.resolve(this.success(undefined));
    }
    dispose() {
        this.interface.removeAllListeners();
        this.interface.close();
        this.listening = false;
        this.listenAbortController.abort();
    }
}
exports.UdpApi = UdpApi;
//# sourceMappingURL=udp.js.map