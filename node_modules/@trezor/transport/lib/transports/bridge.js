"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeTransport = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@trezor/utils");
const protocol_1 = require("@trezor/protocol");
const bridgeApiCall_1 = require("../utils/bridgeApiCall");
const bridgeApiResult = tslib_1.__importStar(require("../utils/bridgeApiResult"));
const bridgeProtocolMessage_1 = require("../utils/bridgeProtocolMessage");
const send_1 = require("../utils/send");
const receive_1 = require("../utils/receive");
const abstract_1 = require("./abstract");
const ERRORS = tslib_1.__importStar(require("../errors"));
const DEFAULT_URL = 'http://127.0.0.1:21325';
class BridgeTransport extends abstract_1.AbstractTransport {
    constructor(params) {
        const _a = params || {}, { url = DEFAULT_URL, latestVersion } = _a, rest = tslib_1.__rest(_a, ["url", "latestVersion"]);
        super(rest);
        this.useProtocolMessages = false;
        this.name = 'BridgeTransport';
        this.apiType = 'usb';
        this.url = url;
        this.latestVersion = latestVersion;
    }
    init({ signal } = {}) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.post('/', {
                signal,
            });
            if (!response.success) {
                return response;
            }
            this.version = response.payload.version;
            if (this.latestVersion) {
                this.isOutdated = utils_1.versionUtils.isNewer(this.latestVersion, this.version);
            }
            this.useProtocolMessages = !!response.payload.protocolMessages;
            this.stopped = false;
            return this.success(undefined);
        }), { signal });
    }
    listen() {
        if (this.listening) {
            return this.error({ error: ERRORS.ALREADY_LISTENING });
        }
        this.listening = true;
        this.listenLoop();
        return this.success(undefined);
    }
    listenLoop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            while (!this.stopped) {
                const listenTimestamp = Date.now();
                const response = yield this.post('/listen', {
                    body: this.descriptors,
                    signal: this.abortController.signal,
                });
                if (!response.success) {
                    const time = Date.now() - listenTimestamp;
                    if (time <= 1100) {
                        this.emit('transport-error', response.error);
                        break;
                    }
                    yield (0, utils_1.createTimeoutPromise)(1000);
                }
                else {
                    this.handleDescriptorsChange(response.payload);
                }
            }
        });
    }
    enumerate({ signal } = {}) {
        return this.scheduleAction(signal => this.post('/enumerate', { signal }), { signal });
    }
    acquire({ input, signal }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const response = yield this.post('/acquire', {
                params: `${input.path}/${(_a = input.previous) !== null && _a !== void 0 ? _a : 'null'}`,
                signal,
                body: {
                    sessionOwner: this.id,
                },
            });
            return response;
        }), { signal }, [ERRORS.DEVICE_DISCONNECTED_DURING_ACTION, ERRORS.SESSION_WRONG_PREVIOUS]);
    }
    release({ path: _, session, onClose, signal, }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const releasePromise = this.post('/release', {
                params: session,
                signal,
            });
            if (onClose) {
                return Promise.resolve(this.success(null));
            }
            const response = yield releasePromise;
            return response.success ? this.success(null) : response;
        }), { signal });
    }
    releaseDevice() {
        return Promise.resolve(this.success(undefined));
    }
    getProtocol(customProtocol) {
        if (!this.useProtocolMessages) {
            return protocol_1.bridge;
        }
        return customProtocol || protocol_1.v1;
    }
    getRequestBody(body, protocol) {
        return (0, bridgeProtocolMessage_1.createProtocolMessage)(body, this.useProtocolMessages ? protocol : undefined);
    }
    call({ session, name, data, protocol: customProtocol, signal, }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const protocol = this.getProtocol(customProtocol);
            const bytes = (0, send_1.buildMessage)({
                messages: this.messages,
                name,
                data,
                encode: protocol.encode,
            });
            const response = yield this.post(`/call`, {
                params: session,
                body: this.getRequestBody(bytes, protocol),
                signal,
            });
            if (!response.success) {
                return response;
            }
            return (0, receive_1.receiveAndParse)(this.messages, () => Promise.resolve(this.success(Buffer.from(response.payload.data, 'hex'))), protocol);
        }), { signal, timeout: undefined });
    }
    send({ session, name, data, protocol: customProtocol, signal, }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const protocol = this.getProtocol(customProtocol);
            const bytes = (0, send_1.buildMessage)({
                messages: this.messages,
                name,
                data,
                encode: protocol.encode,
            });
            const response = yield this.post('/post', {
                params: session,
                body: this.getRequestBody(bytes, protocol),
                signal,
            });
            if (!response.success) {
                return response;
            }
            return this.success(undefined);
        }), { signal });
    }
    receive({ session, protocol: customProtocol, signal, }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const protocol = this.getProtocol(customProtocol);
            const response = yield this.post('/read', {
                params: session,
                body: this.getRequestBody(Buffer.alloc(0), protocol),
                signal,
            });
            if (!response.success) {
                return response;
            }
            return (0, receive_1.receiveAndParse)(this.messages, () => Promise.resolve(this.success(Buffer.from(response.payload.data, 'hex'))), protocol);
        }), { signal, timeout: undefined });
    }
    post(endpoint, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield (0, bridgeApiCall_1.bridgeApiCall)(Object.assign(Object.assign({}, options), { method: 'POST', url: `${this.url + endpoint}${(options === null || options === void 0 ? void 0 : options.params) ? `/${options.params}` : ''}`, skipContentTypeHeader: true }));
            if (!response.success) {
                if (response.error === ERRORS.UNEXPECTED_ERROR) {
                    return this.unknownError(response.error);
                }
                if (response.error === ERRORS.HTTP_ERROR) {
                    return this.error({ error: response.error });
                }
                switch (endpoint) {
                    case '/':
                        return this.unknownError(response.error);
                    case '/acquire':
                        return this.unknownError(response.error, [
                            ERRORS.SESSION_WRONG_PREVIOUS,
                            ERRORS.DEVICE_NOT_FOUND,
                            ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE,
                            ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                            ERRORS.LIBUSB_ERROR_ACCESS,
                        ]);
                    case '/call':
                    case '/read':
                    case '/post':
                        return this.unknownError(response.error, [
                            ERRORS.SESSION_NOT_FOUND,
                            ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                            ERRORS.OTHER_CALL_IN_PROGRESS,
                            ERRORS.INTERFACE_DATA_TRANSFER,
                            protocol_1.PROTOCOL_MALFORMED,
                        ]);
                    case '/enumerate':
                    case '/listen':
                        return this.unknownError(response.error);
                    case '/release':
                        return this.unknownError(response.error, [
                            ERRORS.SESSION_NOT_FOUND,
                            ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                        ]);
                    default:
                        return this.error({
                            error: ERRORS.WRONG_RESULT_TYPE,
                            message: 'just for type safety, should never happen',
                        });
                }
            }
            switch (endpoint) {
                case '/':
                    return bridgeApiResult.info(response.payload);
                case '/acquire':
                    return bridgeApiResult.acquire(response.payload);
                case '/read':
                case '/call':
                    return bridgeApiResult.call(response.payload);
                case '/post':
                    return bridgeApiResult.post(response.payload);
                case '/enumerate':
                case '/listen':
                    return bridgeApiResult.devices(response.payload);
                case '/release':
                    return bridgeApiResult.empty(response.payload);
                default:
                    return this.error({
                        error: ERRORS.WRONG_RESULT_TYPE,
                        message: 'just for type safety, should never happen',
                    });
            }
        });
    }
}
exports.BridgeTransport = BridgeTransport;
//# sourceMappingURL=bridge.js.map