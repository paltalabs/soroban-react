"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.receive = receive;
exports.receiveAndParse = receiveAndParse;
const tslib_1 = require("tslib");
const protobuf_1 = require("@trezor/protobuf");
const result_1 = require("./result");
function receive(receiver, protocol) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const readResult = yield receiver();
        if (!readResult.success) {
            return readResult;
        }
        const data = readResult.payload;
        const { length, messageType, payload } = protocol.decode(data);
        const result = Buffer.alloc(length);
        const chunkHeader = protocol.getChunkHeader(Buffer.from(data));
        payload.copy(result);
        let offset = payload.length;
        while (offset < length) {
            const readResult = yield receiver();
            if (!readResult.success) {
                return readResult;
            }
            const data = readResult.payload;
            Buffer.from(data).copy(result, offset, chunkHeader.byteLength);
            offset += data.byteLength - chunkHeader.byteLength;
        }
        return (0, result_1.success)({ messageType, payload: result });
    });
}
function receiveAndParse(messages, receiver, protocol) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const readResult = yield receive(receiver, protocol);
        if (!readResult.success)
            return readResult;
        const { messageType, payload } = readResult.payload;
        const { Message, messageName } = (0, protobuf_1.createMessageFromType)(messages, messageType);
        const message = (0, protobuf_1.decode)(Message, payload);
        return (0, result_1.success)({
            message,
            type: messageName,
        });
    });
}
//# sourceMappingURL=receive.js.map