"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelease = exports.getFirmwareStatus = exports.getInfo = exports.getReleases = exports.parseFirmware = void 0;
const utils_1 = require("@trezor/utils");
const firmwareUtils_1 = require("../utils/firmwareUtils");
const types_1 = require("../types");
const releases = Object.values(types_1.DeviceModelInternal).reduce((acc, key) => ({ ...acc, [key]: [] }), {});
const parseFirmware = (json, deviceModel) => {
    Object.keys(json).forEach(key => {
        var _a;
        const release = json[key];
        (_a = releases[deviceModel]) === null || _a === void 0 ? void 0 : _a.push({
            ...release,
        });
    });
};
exports.parseFirmware = parseFirmware;
const getReleases = (deviceModel) => releases[deviceModel] || [];
exports.getReleases = getReleases;
const getChangelog = (releases2, features) => {
    if (features.bootloader_mode) {
        if (features.firmware_present && features.major_version === 1) {
            return null;
        }
        if (features.firmware_present && features.major_version === 2) {
            return releases2.filter(r => utils_1.versionUtils.isNewer(r.version, [
                features.fw_major,
                features.fw_minor,
                features.fw_patch,
            ]));
        }
        return releases2;
    }
    return releases2.filter(r => utils_1.versionUtils.isNewer(r.version, [
        features.major_version,
        features.minor_version,
        features.patch_version,
    ]));
};
const isNewer = (release, features) => {
    if (features.major_version === 1 && features.bootloader_mode) {
        return null;
    }
    return utils_1.versionUtils.isNewer(release.version, [
        features.major_version,
        features.minor_version,
        features.patch_version,
    ]);
};
const isRequired = (changelog) => {
    if (!changelog || !changelog.length)
        return null;
    return changelog.some(item => item.required);
};
const isEqual = (release, latest) => utils_1.versionUtils.isEqual(release.version, latest.version);
const getT1BootloaderVersion = (releases2, features) => {
    const { bootloader_mode, major_version, minor_version, patch_version } = features;
    const versionArray = [major_version, minor_version, patch_version];
    if (bootloader_mode) {
        return versionArray;
    }
    const release = releases2.find(({ version }) => utils_1.versionUtils.isEqual(version, versionArray));
    return (release === null || release === void 0 ? void 0 : release.bootloader_version) || [1, 0, 0];
};
const getIntermediaryVersion = (releases2, features, offerLatest) => {
    if (features.major_version !== 1 || offerLatest) {
        return;
    }
    const bootloaderVersion = getT1BootloaderVersion(releases2, features);
    if (utils_1.versionUtils.isNewerOrEqual(bootloaderVersion, [1, 12, 0])) {
        return 3;
    }
    if (utils_1.versionUtils.isNewerOrEqual(bootloaderVersion, [1, 8, 0])) {
        return 2;
    }
    return 1;
};
const getSafeReleases = ({ features, releases }) => {
    const { bootloader_mode, major_version, minor_version, patch_version, fw_major, fw_minor, fw_patch, } = features;
    const firmwareVersion = [major_version, minor_version, patch_version];
    if (!utils_1.versionUtils.isVersionArray(firmwareVersion)) {
        return [];
    }
    if (major_version === 2 && bootloader_mode) {
        const fwVersion = [fw_major, fw_minor, fw_patch];
        if (utils_1.versionUtils.isVersionArray(fwVersion)) {
            return (0, firmwareUtils_1.filterSafeListByFirmware)(releases, fwVersion);
        }
        return (0, firmwareUtils_1.filterSafeListByBootloader)(releases, firmwareVersion);
    }
    if (major_version === 1 && bootloader_mode) {
        return (0, firmwareUtils_1.filterSafeListByBootloader)(releases, firmwareVersion);
    }
    return (0, firmwareUtils_1.filterSafeListByFirmware)(releases, firmwareVersion);
};
const getInfo = ({ features, releases }) => {
    if (!Array.isArray(releases) || releases.length < 1) {
        return null;
    }
    if (!(0, firmwareUtils_1.isStrictFeatures)(features)) {
        throw new Error('Features of unexpected shape provided.');
    }
    if (!(0, firmwareUtils_1.isValidReleases)(releases)) {
        throw new Error(`Release object in unexpected shape.`);
    }
    const latest = releases[0];
    const releasesSafe = getSafeReleases({ features, releases });
    if (!releasesSafe.length) {
        return null;
    }
    const releasesParsed = features.major_version === 1 ? releases : releasesSafe;
    const changelog = getChangelog(releasesParsed, features);
    const release = releasesParsed[0];
    const prevRelease = releasesParsed[1];
    const intermediaryVersion = getIntermediaryVersion(releases, features, isEqual(releasesSafe[0], latest));
    const isNewerResult = isNewer(latest, features);
    return {
        changelog,
        release,
        isRequired: isRequired(changelog),
        isNewer: isNewerResult,
        intermediaryVersion,
        translations: isNewerResult ? prevRelease === null || prevRelease === void 0 ? void 0 : prevRelease.translations : release === null || release === void 0 ? void 0 : release.translations,
    };
};
exports.getInfo = getInfo;
const getFirmwareStatus = (features) => {
    if (features.firmware_present === false) {
        return 'none';
    }
    if (features.major_version === 1 && features.bootloader_mode) {
        return 'unknown';
    }
    const info = (0, exports.getInfo)({
        features,
        releases: (0, exports.getReleases)(features === null || features === void 0 ? void 0 : features.internal_model),
    });
    if (!info)
        return 'custom';
    if (info.isRequired)
        return 'required';
    if (info.isNewer)
        return 'outdated';
    return 'valid';
};
exports.getFirmwareStatus = getFirmwareStatus;
const getRelease = (features) => (0, exports.getInfo)({
    features,
    releases: (0, exports.getReleases)(features === null || features === void 0 ? void 0 : features.internal_model),
});
exports.getRelease = getRelease;
//# sourceMappingURL=firmwareInfo.js.map