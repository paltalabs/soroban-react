import { Transport, Session } from '@trezor/transport';
import { MessagesSchema as Messages } from '@trezor/protobuf';
import { Device } from './Device';
import type { CoinInfo, BitcoinNetworkInfo } from '../types';
import type { HDNodeResponse } from '../types/api/getPublicKey';
type MessageType = Messages.MessageType;
type MessageKey = keyof MessageType;
type TypedPayload<T extends MessageKey> = {
    type: T;
    message: MessageType[T];
};
type TypedCallResponseMap = {
    [K in keyof MessageType]: TypedPayload<K>;
};
type DefaultPayloadMessage = TypedCallResponseMap[keyof MessageType];
export declare class DeviceCommands {
    device: Device;
    transport: Transport;
    transportSession: Session;
    disposed: boolean;
    callPromise?: ReturnType<Transport['call']>;
    constructor(device: Device, transport: Transport, transportSession: Session);
    dispose(): void;
    isDisposed(): boolean;
    unlockPath(params?: Messages.UnlockPath): Promise<TypedPayload<"UnlockedPathRequest">>;
    getPublicKey(params: Messages.GetPublicKey, unlockPath?: Messages.UnlockPath): Promise<{
        descriptor?: string | undefined;
        root_fingerprint?: number | undefined;
        node: {
            private_key?: string | undefined;
            public_key: string;
            depth: number;
            fingerprint: number;
            child_num: number;
            chain_code: string;
        };
        xpub: string;
    }>;
    getHDNode(params: Messages.GetPublicKey, options: {
        coinInfo: BitcoinNetworkInfo;
        validation?: boolean;
        unlockPath?: Messages.UnlockPath;
    }): Promise<{
        xpubSegwit?: string | undefined;
        descriptorChecksum?: string | undefined;
        path: number[];
        publicKey: string;
        serializedPath: string;
        depth: number;
        fingerprint: number;
        chainCode: string;
        childNum: number;
        xpub: string;
    }>;
    getAddress({ address_n, show_display, multisig, script_type, chunkify }: Messages.GetAddress, coinInfo: BitcoinNetworkInfo): Promise<{
        path: number[];
        serializedPath: string;
        address: string;
    }>;
    ethereumGetAddress({ address_n, show_display, encoded_network, chunkify, }: Messages.EthereumGetAddress): Promise<{
        path: number[];
        serializedPath: string;
        address: string;
    }>;
    ethereumGetPublicKey({ address_n, show_display, }: Messages.EthereumGetPublicKey): Promise<HDNodeResponse>;
    preauthorize(throwError: boolean): Promise<boolean>;
    getDeviceState(): Promise<string>;
    private call;
    typedCall<T extends MessageKey, R extends MessageKey[]>(type: T, resType: R, msg?: MessageType[T]): Promise<TypedCallResponseMap[R[number]]>;
    typedCall<T extends MessageKey, R extends MessageKey>(type: T, resType: R, msg?: MessageType[T]): Promise<TypedPayload<R>>;
    _commonCall(type: MessageKey, msg?: DefaultPayloadMessage['message']): Promise<DefaultPayloadMessage>;
    _filterCommonTypes(res: DefaultPayloadMessage): Promise<DefaultPayloadMessage>;
    private _getAddress;
    getAccountDescriptor(coinInfo: CoinInfo, indexOrPath: number | number[], derivationType?: Messages.CardanoDerivationType): Promise<{
        descriptor: string;
        legacyXpub?: string;
        address_n: number[];
        descriptorChecksum?: string;
    }>;
    cancelWithFallback(): Promise<{
        readonly success: false;
        readonly error: "session not found";
    } | import("@trezor/transport/lib/types").Success<import("@trezor/protobuf").MessageFromTrezor> | import("@trezor/transport/lib/types").ErrorGeneric<"session not found" | "Network request failed" | "Wrong result type." | "other call in progress" | "Malformed protocol format" | "device disconnected during action" | "unexpected error" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "A transfer error has occurred."> | import("@trezor/transport/lib/types").Success<undefined> | undefined>;
    cancel(): Promise<void>;
}
export type TypedCall = DeviceCommands['typedCall'];
export {};
//# sourceMappingURL=DeviceCommands.d.ts.map