import { TypedEmitter } from '@trezor/utils';
import { Session } from '@trezor/transport';
import { TransportProtocol } from '@trezor/protocol';
import { type Transport, type Descriptor } from '@trezor/transport';
import { DeviceCommands } from './DeviceCommands';
import { PROTO } from '../constants';
import { DEVICE, DeviceButtonRequestPayload, UiResponsePin, UiResponsePassphrase, UiResponseWord } from '../events';
import { Device as DeviceTyped, DeviceFirmwareStatus, DeviceState, ReleaseInfo, UnavailableCapabilities, FirmwareType, VersionArray, DeviceUniquePath } from '../types';
import { IStateStorage } from './StateStorage';
import type { PromptCallback } from './prompts';
export type RunOptions = {
    skipFinalReload?: boolean;
    waiting?: boolean;
    onlyOneActivity?: boolean;
    cancelPopupRequest?: () => any;
    keepSession?: boolean;
    useCardanoDerivation?: boolean;
};
export declare const GET_FEATURES_TIMEOUT = 3000;
export declare const GET_FEATURES_TIMEOUT_REACT_NATIVE = 20000;
export interface DeviceEvents {
    [DEVICE.PIN]: (device: Device, type: PROTO.PinMatrixRequestType | undefined, callback: PromptCallback<UiResponsePin['payload']>) => void;
    [DEVICE.WORD]: (device: Device, type: PROTO.WordRequestType, callback: PromptCallback<UiResponseWord['payload']>) => void;
    [DEVICE.PASSPHRASE]: (device: Device, callback: PromptCallback<UiResponsePassphrase['payload']>) => void;
    [DEVICE.PASSPHRASE_ON_DEVICE]: () => void;
    [DEVICE.BUTTON]: (device: Device, payload: DeviceButtonRequestPayload) => void;
}
type DeviceLifecycle = typeof DEVICE.CONNECT | typeof DEVICE.CONNECT_UNACQUIRED | typeof DEVICE.DISCONNECT | typeof DEVICE.CHANGED;
type DeviceLifecycleListener = (lifecycle: DeviceLifecycle) => void;
type DeviceParams = {
    id: DeviceUniquePath;
    transport: Transport;
    descriptor: Descriptor;
    listener: DeviceLifecycleListener;
};
export declare class Device extends TypedEmitter<DeviceEvents> {
    readonly transport: Transport;
    readonly protocol: TransportProtocol;
    private readonly transportPath;
    private readonly transportSessionOwner;
    private readonly transportDescriptorType;
    private session;
    private lastAcquiredHere;
    private unreadableError?;
    private _firmwareStatus;
    get firmwareStatus(): DeviceFirmwareStatus;
    private _firmwareRelease?;
    get firmwareRelease(): ReleaseInfo | null | undefined;
    private _features;
    get features(): {
        _passphrase_cached?: boolean | undefined;
        busy?: boolean | undefined;
        homescreen_format?: "Toif" | "Jpeg" | "ToiG" | undefined;
        hide_passphrase_from_host?: boolean | undefined;
        unit_color?: number | undefined;
        unit_btconly?: boolean | undefined;
        homescreen_width?: number | undefined;
        homescreen_height?: number | undefined;
        bootloader_locked?: boolean | undefined;
        language_version_matches?: boolean | undefined;
        unit_packaging?: number | undefined;
        haptic_feedback?: boolean | undefined;
        recovery_type?: "NormalRecovery" | "DryRun" | "UnlockRepeatedBackup" | undefined;
        optiga_sec?: number | undefined;
        vendor: string;
        major_version: number;
        minor_version: number;
        patch_version: number;
        bootloader_mode: boolean | null;
        device_id: string | null;
        pin_protection: boolean | null;
        passphrase_protection: boolean | null;
        language: string | null;
        label: string | null;
        initialized: boolean | null;
        revision: string | null;
        bootloader_hash: string | null;
        imported: boolean | null;
        unlocked: boolean | null;
        firmware_present: boolean | null;
        backup_availability: "NotAvailable" | "Required" | "Available" | null;
        flags: number | null;
        model: string;
        fw_major: number | null;
        fw_minor: number | null;
        fw_patch: number | null;
        fw_vendor: string | null;
        unfinished_backup: boolean | null;
        no_backup: boolean | null;
        recovery_status: "Nothing" | "Recovery" | "Backup" | null;
        capabilities: ("Capability_Bitcoin" | "Capability_Bitcoin_like" | "Capability_Binance" | "Capability_Cardano" | "Capability_Crypto" | "Capability_EOS" | "Capability_Ethereum" | "Capability_Lisk" | "Capability_Monero" | "Capability_NEM" | "Capability_Ripple" | "Capability_Stellar" | "Capability_Tezos" | "Capability_U2F" | "Capability_Shamir" | "Capability_ShamirGroups" | "Capability_PassphraseEntry" | "Capability_Solana" | "Capability_Translations" | "Capability_Brightness" | "Capability_Haptic")[];
        backup_type: "Bip39" | "Slip39_Basic" | "Slip39_Advanced" | "Slip39_Single_Extendable" | "Slip39_Basic_Extendable" | "Slip39_Advanced_Extendable" | null;
        sd_card_present: boolean | null;
        sd_protection: boolean | null;
        wipe_code_protection: boolean | null;
        session_id: string | null;
        passphrase_always_on_device: boolean | null;
        safety_checks: "Strict" | "PromptAlways" | "PromptTemporarily" | null;
        auto_lock_delay_ms: number | null;
        display_rotation: "North" | "East" | "South" | "West" | null;
        experimental_features: boolean | null;
        internal_model: PROTO.DeviceModelInternal;
    };
    private _featuresNeedsReload;
    private acquirePromise?;
    private releasePromise?;
    private runPromise?;
    private keepTransportSession;
    commands?: DeviceCommands;
    private cancelableAction?;
    private loaded;
    private inconsistent;
    private firstRunPromise;
    private instance;
    private state;
    private stateStorage?;
    private _unavailableCapabilities;
    get unavailableCapabilities(): Readonly<UnavailableCapabilities>;
    private _firmwareType?;
    get firmwareType(): FirmwareType | undefined;
    private name;
    private color?;
    private availableTranslations;
    private authenticityChecks;
    private readonly uniquePath;
    private readonly emitLifecycle;
    private sessionDfd?;
    constructor({ id, transport, descriptor, listener }: DeviceParams);
    private getSessionChangePromise;
    private waitAndCompareSession;
    acquire(): import("@trezor/transport/lib/types").AsyncResultWithTypedError<Session, "Network request failed" | "Wrong result type." | "device disconnected during action" | "unexpected error" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "descriptor not found" | "wrong previous session" | "LIBUSB_ERROR_ACCESS">;
    release(): Promise<import("@trezor/transport/lib/types").Success<null> | import("@trezor/transport/lib/types").ErrorGeneric<"session not found" | "Network request failed" | "Wrong result type." | "device disconnected during action" | "unexpected error" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "wrong previous session"> | undefined>;
    releaseTransportSession(): void;
    cleanup(release?: boolean): Promise<void>;
    handshake(delay?: number): Promise<void>;
    updateDescriptor(descriptor: Descriptor): Promise<void>;
    run(fn?: () => Promise<void>, options?: RunOptions): Promise<void>;
    override(error: Error): Promise<void>;
    setCancelableAction(callback: NonNullable<typeof this.cancelableAction>): void;
    clearCancelableAction(): void;
    interruptionFromUser(error: Error): Promise<void>;
    usedElsewhere(): void;
    private _runInner;
    getCommands(): DeviceCommands;
    setInstance(instance?: number): void;
    getInstance(): number;
    getState(): DeviceState | undefined;
    setState(state?: Partial<DeviceState>): void;
    validateState(preauthorized?: boolean): Promise<`${string}@${string}:${number}` | undefined>;
    initialize(useCardanoDerivation: boolean): Promise<void>;
    initStorage(storage: IStateStorage): void;
    getFeatures(): Promise<void>;
    private checkFirmwareHashWithRetries;
    private checkFirmwareHash;
    private checkFirmwareRevisionWithRetries;
    private checkFirmwareRevision;
    changeLanguage({ language, binary, }: {
        language?: undefined;
        binary: ArrayBuffer;
    } | {
        language: string;
        binary?: undefined;
    }): Promise<{
        message: string;
    }>;
    private _uploadTranslationData;
    private _updateFeatures;
    isUnacquired(): boolean;
    isUnreadable(): boolean;
    disconnect(): Promise<void>;
    isBootloader(): boolean;
    isInitialized(): boolean;
    isSeedless(): boolean;
    isInconsistent(): boolean;
    getVersion(): VersionArray | undefined;
    atLeast(versions: string[] | string): boolean;
    isUsed(): boolean;
    isUsedHere(): boolean;
    isUsedElsewhere(): boolean;
    isRunning(): boolean;
    isLoaded(): boolean;
    waitForFirstRun(): Promise<boolean>;
    getLocalSession(): Session | null;
    getUniquePath(): DeviceUniquePath;
    isT1(): boolean;
    hasUnexpectedMode(allow: string[], require: string[]): "ui-device_bootloader_mode" | "ui-device_not_in_bootloader_mode" | "ui-device_not_initialized" | "ui-device_seedless" | null;
    dispose(): Promise<import("@trezor/transport/lib/types").Success<null> | import("@trezor/transport/lib/types").ErrorGeneric<"session not found" | "Network request failed" | "Wrong result type." | "device disconnected during action" | "unexpected error" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "wrong previous session"> | undefined>;
    private getMode;
    toMessageObject(): DeviceTyped;
}
export {};
//# sourceMappingURL=Device.d.ts.map