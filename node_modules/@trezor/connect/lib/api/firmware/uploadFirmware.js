"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadFirmware = void 0;
const events_1 = require("../../events");
const constants_1 = require("../../constants");
const postConfirmationMessage = (device) => {
    if (device.features.firmware_present) {
        device.emit(events_1.DEVICE.BUTTON, device, { code: 'ButtonRequest_FirmwareUpdate' });
    }
};
const postProgressMessage = (device, progress, postMessage) => {
    postMessage((0, events_1.createUiMessage)(events_1.UI.FIRMWARE_PROGRESS, {
        device: device.toMessageObject(),
        operation: 'flashing',
        progress,
    }));
};
const uploadFirmware = async (typedCall, postMessage, device, { payload }) => {
    if (device.features.major_version === 1) {
        postConfirmationMessage(device);
        await typedCall('FirmwareErase', 'Success', {});
        postProgressMessage(device, 0, postMessage);
        let i = 0;
        const progressTimer = setInterval(() => {
            i++;
            postProgressMessage(device, Math.min(i * 2, 99), postMessage);
        }, 300);
        const message = await typedCall('FirmwareUpload', 'Success', {
            payload,
        }).finally(() => {
            clearInterval(progressTimer);
        });
        postProgressMessage(device, 100, postMessage);
        return message;
    }
    if (device.features.major_version === 2) {
        postConfirmationMessage(device);
        const length = payload.byteLength;
        let response = await typedCall('FirmwareErase', ['FirmwareRequest', 'Success'], { length });
        while (response.type !== 'Success') {
            const start = response.message.offset;
            const end = response.message.offset + response.message.length;
            const chunk = payload.slice(start, end);
            if (start > 0) {
                postProgressMessage(device, Math.round((start / length) * 100), postMessage);
            }
            response = await typedCall('FirmwareUpload', ['FirmwareRequest', 'Success'], {
                payload: chunk,
            });
        }
        postProgressMessage(device, 100, postMessage);
        return response.message;
    }
    throw constants_1.ERRORS.TypedError('Runtime', 'uploadFirmware: unknown major_version');
};
exports.uploadFirmware = uploadFirmware;
//# sourceMappingURL=uploadFirmware.js.map