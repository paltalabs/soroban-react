"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeeLevels = void 0;
const bigNumber_1 = require("@trezor/utils/lib/bigNumber");
const convertFeeRate = (fee, minFee) => {
    const feePerKB = new bigNumber_1.BigNumber(fee);
    if (feePerKB.isNaN() || feePerKB.lte('0'))
        return;
    const feePerB = feePerKB.div(1000);
    if (feePerB.lt(minFee))
        return minFee.toString();
    return feePerB.isInteger() ? feePerB.toString() : feePerB.toFixed(2);
};
const fillGap = (from, step, size) => {
    const fill = [];
    for (let i = from + step; i <= from + size; i += step) {
        fill.push(i);
    }
    return fill;
};
const findNearest = (requested, blocks) => {
    if (typeof blocks[requested] === 'string')
        return blocks[requested];
    const len = blocks.length;
    let index = requested;
    while (typeof blocks[index] !== 'string' && index < len) {
        index++;
    }
    if (typeof blocks[index] === 'string') {
        return blocks[index];
    }
    index = requested;
    while (typeof blocks[index] !== 'string' && index > 0) {
        index--;
    }
    return blocks[index];
};
const findLowest = (blocks) => blocks
    .slice(0)
    .reverse()
    .find(item => typeof item === 'string');
const findBlocksForFee = (feePerUnit, blocks) => {
    const bn = new bigNumber_1.BigNumber(feePerUnit);
    const lower = blocks.find(b => typeof b === 'string' && bn.gte(b));
    if (!lower)
        return -1;
    return blocks.indexOf(lower);
};
class FeeLevels {
    constructor(coinInfo) {
        this.blocks = [];
        this.coinInfo = coinInfo;
        this.levels = coinInfo.defaultFees;
    }
    async loadMisc(blockchain) {
        try {
            const [response] = await blockchain.estimateFee({ blocks: [1] });
            this.levels[0] = {
                ...this.levels[0],
                ...response,
                feePerUnit: Math.min(this.coinInfo.maxFee, Math.max(this.coinInfo.minFee, parseInt(response.feePerUnit, 10))).toString(),
            };
        }
        catch {
        }
        return this.levels;
    }
    async load(blockchain) {
        if (this.coinInfo.type !== 'bitcoin')
            return this.loadMisc(blockchain);
        let blocks = fillGap(0, 1, 10);
        if (this.levels.length > 1) {
            blocks = this.levels
                .map(l => l.blocks)
                .reduce((result, bl) => {
                if (result.length === 0)
                    return result.concat([bl]);
                const from = result[result.length - 1];
                const gap = bl - from;
                const incr = gap <= 30 ? 1 : 6;
                const fill = fillGap(from, incr, gap);
                return result.concat(fill);
            }, []);
        }
        const oneDayBlocks = 6 * 24;
        blocks.push(...fillGap(oneDayBlocks, oneDayBlocks / 2, oneDayBlocks * 6));
        try {
            const response = await blockchain.estimateFee({ blocks });
            response.forEach(({ feePerUnit }, index) => {
                this.blocks[blocks[index]] = convertFeeRate(feePerUnit, this.coinInfo.minFee);
            });
            this.levels.forEach(level => {
                const updatedValue = findNearest(level.blocks, this.blocks);
                if (typeof updatedValue === 'string') {
                    level.blocks = this.blocks.indexOf(updatedValue);
                    level.feePerUnit = updatedValue;
                }
            });
            this.longTermFeeRate = findLowest(this.blocks);
        }
        catch {
        }
        return this.levels;
    }
    updateCustomFee(feePerUnit) {
        this.levels = this.levels.filter(l => l.label !== 'custom');
        const blocks = findBlocksForFee(feePerUnit, this.blocks);
        this.levels.push({
            label: 'custom',
            feePerUnit,
            blocks,
        });
    }
}
exports.FeeLevels = FeeLevels;
//# sourceMappingURL=Fees.js.map