"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrezorConnect = exports.CoreInSuiteDesktop = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("events"));
const events_2 = require("@trezor/connect/lib/events");
const ERRORS = tslib_1.__importStar(require("@trezor/connect/lib/constants/errors"));
const factory_1 = require("@trezor/connect/lib/factory");
const utils_1 = require("@trezor/utils");
const connectSettings_1 = require("../connectSettings");
class CoreInSuiteDesktop {
    constructor() {
        this.eventEmitter = new events_1.default();
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        this.messages = (0, utils_1.createDeferredManager)();
    }
    manifest(data) {
        this._settings = (0, connectSettings_1.parseConnectSettings)(Object.assign(Object.assign({}, this._settings), { manifest: data }));
    }
    dispose() {
        var _a;
        this.eventEmitter.removeAllListeners();
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
        return Promise.resolve(undefined);
    }
    cancel(_error) { }
    async handshake() {
        var _a;
        const { promise, promiseId } = this.messages.create(1000);
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({
            id: promiseId,
            type: events_2.POPUP.HANDSHAKE,
        }));
        try {
            await promise;
        }
        catch (err) {
            console.error(err);
            throw new Error('Handshake timed out');
        }
    }
    async init(settings = {}) {
        var _a, _b;
        const newSettings = (0, connectSettings_1.parseConnectSettings)(Object.assign(Object.assign({}, this._settings), settings));
        if (!((_a = newSettings.transports) === null || _a === void 0 ? void 0 : _a.length)) {
            newSettings.transports = ['BridgeTransport', 'WebUsbTransport'];
        }
        this._settings = newSettings;
        (_b = this.ws) === null || _b === void 0 ? void 0 : _b.close();
        const wsOpen = (0, utils_1.createDeferred)(1000);
        this.ws = new WebSocket('ws://localhost:21335/connect-ws');
        this.ws.addEventListener('opened', () => {
            wsOpen.resolve();
        });
        this.ws.addEventListener('error', () => {
            wsOpen.reject(new Error('WebSocket error'));
            this.messages.rejectAll(new Error('WebSocket error'));
        });
        this.ws.addEventListener('message', (event) => {
            try {
                const data = JSON.parse(event.data);
                this.messages.resolve(data.id, data);
            }
            catch (_a) {
            }
        });
        this.ws.addEventListener('close', () => {
            wsOpen.reject(new Error('WebSocket closed'));
            this.messages.rejectAll(new Error('WebSocket closed'));
        });
        if (this.ws.readyState !== WebSocket.OPEN) {
            setTimeout(() => {
                var _a;
                if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN) {
                    wsOpen.resolve();
                }
            }, 500);
            await wsOpen.promise;
        }
        return await this.handshake();
    }
    async call(params) {
        var _a;
        try {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                await this.init();
            }
            await this.handshake();
            const { promise, promiseId } = this.messages.create();
            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({
                id: promiseId,
                type: events_2.IFRAME.CALL,
                payload: params,
            }));
            return promise;
        }
        catch (err) {
            return {
                success: false,
                payload: {
                    error: err.message,
                },
            };
        }
    }
    uiResponse(_response) {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    requestLogin() {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    disableWebUSB() {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    requestWebUSBDevice() {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    renderWebUSBButton() { }
}
exports.CoreInSuiteDesktop = CoreInSuiteDesktop;
const impl = new CoreInSuiteDesktop();
exports.TrezorConnect = (0, factory_1.factory)({
    eventEmitter: impl.eventEmitter,
    init: impl.init.bind(impl),
    call: impl.call.bind(impl),
    manifest: impl.manifest.bind(impl),
    requestLogin: impl.requestLogin.bind(impl),
    uiResponse: impl.uiResponse.bind(impl),
    cancel: impl.cancel.bind(impl),
    dispose: impl.dispose.bind(impl),
});
//# sourceMappingURL=core-in-suite-desktop.js.map