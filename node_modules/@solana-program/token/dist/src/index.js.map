{"version":3,"sources":["../../src/generated/accounts/mint.ts","../../src/generated/accounts/multisig.ts","../../src/generated/types/accountState.ts","../../src/generated/types/authorityType.ts","../../src/generated/accounts/token.ts","../../src/generated/programs/associatedToken.ts","../../src/generated/programs/token.ts","../../src/generated/errors/associatedToken.ts","../../src/generated/errors/token.ts","../../src/generated/shared/index.ts","../../src/generated/instructions/amountToUiAmount.ts","../../src/generated/instructions/approve.ts","../../src/generated/instructions/approveChecked.ts","../../src/generated/instructions/burn.ts","../../src/generated/instructions/burnChecked.ts","../../src/generated/instructions/closeAccount.ts","../../src/generated/pdas/associatedToken.ts","../../src/generated/instructions/createAssociatedToken.ts","../../src/generated/instructions/createAssociatedTokenIdempotent.ts","../../src/generated/instructions/freezeAccount.ts","../../src/generated/instructions/getAccountDataSize.ts","../../src/generated/instructions/initializeAccount.ts","../../src/generated/instructions/initializeAccount2.ts","../../src/generated/instructions/initializeAccount3.ts","../../src/generated/instructions/initializeImmutableOwner.ts","../../src/generated/instructions/initializeMint.ts","../../src/generated/instructions/initializeMint2.ts","../../src/generated/instructions/initializeMultisig.ts","../../src/generated/instructions/initializeMultisig2.ts","../../src/generated/instructions/mintTo.ts","../../src/generated/instructions/mintToChecked.ts","../../src/generated/instructions/recoverNestedAssociatedToken.ts","../../src/generated/instructions/revoke.ts","../../src/generated/instructions/setAuthority.ts","../../src/generated/instructions/syncNative.ts","../../src/generated/instructions/thawAccount.ts","../../src/generated/instructions/transfer.ts","../../src/generated/instructions/transferChecked.ts","../../src/generated/instructions/uiAmountToAmount.ts"],"names":["getStructEncoder","getOptionEncoder","getAddressEncoder","getU32Encoder","getU64Encoder","getU8Encoder","getBooleanEncoder","getStructDecoder","getOptionDecoder","getAddressDecoder","getU32Decoder","getU64Decoder","getU8Decoder","getBooleanDecoder","combineCodec","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","getArrayEncoder","getArrayDecoder","AccountState","getEnumEncoder","getEnumDecoder","AuthorityType","AssociatedTokenInstruction","containsBytes","TokenAccount","TokenInstruction","isProgramError","AccountRole","upgradeRoleToSigner","web3JsIsTransactionSigner","transformEncoder","getProgramDerivedAddress","none","getUtf8Encoder","getUtf8Decoder"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/web3.js';\n\nexport type Mint = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: Option<Address>;\n  /** Total supply of tokens. */\n  supply: bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type MintArgs = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: OptionOrNullable<Address>;\n  /** Total supply of tokens. */\n  supply: number | bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getMintEncoder(): Encoder<MintArgs> {\n  return getStructEncoder([\n    [\n      'mintAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Encoder()],\n    ['decimals', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    [\n      'freezeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getMintDecoder(): Decoder<Mint> {\n  return getStructDecoder([\n    [\n      'mintAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    [\n      'freezeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getMintCodec(): Codec<MintArgs, Mint> {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\n\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Mint, TAddress> | MaybeAccount<Mint, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMintDecoder()\n  );\n}\n\nexport async function fetchMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Mint, TAddress>> {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Mint, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\n\nexport async function fetchAllMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Mint>[]> {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Mint>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\n\nexport function getMintSize(): number {\n  return 82;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/web3.js';\n\nexport type Multisig = {\n  /** Number of signers required. */\n  m: number;\n  /** Number of valid signers. */\n  n: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Signer public keys. */\n  signers: Array<Address>;\n};\n\nexport type MultisigArgs = Multisig;\n\nexport function getMultisigEncoder(): Encoder<MultisigArgs> {\n  return getStructEncoder([\n    ['m', getU8Encoder()],\n    ['n', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    ['signers', getArrayEncoder(getAddressEncoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigDecoder(): Decoder<Multisig> {\n  return getStructDecoder([\n    ['m', getU8Decoder()],\n    ['n', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    ['signers', getArrayDecoder(getAddressDecoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigCodec(): Codec<MultisigArgs, Multisig> {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\n\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Multisig, TAddress> | MaybeAccount<Multisig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMultisigDecoder()\n  );\n}\n\nexport async function fetchMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Multisig, TAddress>> {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Multisig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\n\nexport async function fetchAllMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Multisig>[]> {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Multisig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\n\nexport function getMultisigSize(): number {\n  return 355;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/web3.js';\n\nexport enum AccountState {\n  Uninitialized,\n  Initialized,\n  Frozen,\n}\n\nexport type AccountStateArgs = AccountState;\n\nexport function getAccountStateEncoder(): Encoder<AccountStateArgs> {\n  return getEnumEncoder(AccountState);\n}\n\nexport function getAccountStateDecoder(): Decoder<AccountState> {\n  return getEnumDecoder(AccountState);\n}\n\nexport function getAccountStateCodec(): Codec<AccountStateArgs, AccountState> {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/web3.js';\n\nexport enum AuthorityType {\n  MintTokens,\n  FreezeAccount,\n  AccountOwner,\n  CloseAccount,\n}\n\nexport type AuthorityTypeArgs = AuthorityType;\n\nexport function getAuthorityTypeEncoder(): Encoder<AuthorityTypeArgs> {\n  return getEnumEncoder(AuthorityType);\n}\n\nexport function getAuthorityTypeDecoder(): Decoder<AuthorityType> {\n  return getEnumDecoder(AuthorityType);\n}\n\nexport function getAuthorityTypeCodec(): Codec<\n  AuthorityTypeArgs,\n  AuthorityType\n> {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/web3.js';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport type Token = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: Option<Address>;\n  /** The account's state. */\n  state: AccountState;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: Option<bigint>;\n  /** The amount delegated. */\n  delegatedAmount: bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: Option<Address>;\n};\n\nexport type TokenArgs = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: number | bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: OptionOrNullable<Address>;\n  /** The account's state. */\n  state: AccountStateArgs;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: OptionOrNullable<number | bigint>;\n  /** The amount delegated. */\n  delegatedAmount: number | bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getTokenEncoder(): Encoder<TokenArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['owner', getAddressEncoder()],\n    ['amount', getU64Encoder()],\n    [\n      'delegate',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateEncoder()],\n    [\n      'isNative',\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Encoder()],\n    [\n      'closeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getTokenDecoder(): Decoder<Token> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['owner', getAddressDecoder()],\n    ['amount', getU64Decoder()],\n    [\n      'delegate',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateDecoder()],\n    [\n      'isNative',\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Decoder()],\n    [\n      'closeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getTokenCodec(): Codec<TokenArgs, Token> {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\n\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Token, TAddress> | MaybeAccount<Token, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenDecoder()\n  );\n}\n\nexport async function fetchToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Token, TAddress>> {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Token, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\n\nexport async function fetchAllToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Token>[]> {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Token>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\n\nexport function getTokenSize(): number {\n  return 165;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/web3.js';\nimport {\n  type ParsedCreateAssociatedTokenIdempotentInstruction,\n  type ParsedCreateAssociatedTokenInstruction,\n  type ParsedRecoverNestedAssociatedTokenInstruction,\n} from '../instructions';\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ADDRESS =\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n\nexport enum AssociatedTokenInstruction {\n  CreateAssociatedToken,\n  CreateAssociatedTokenIdempotent,\n  RecoverNestedAssociatedToken,\n}\n\nexport function identifyAssociatedTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AssociatedTokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedToken;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a associatedToken instruction.'\n  );\n}\n\nexport type ParsedAssociatedTokenInstruction<\n  TProgram extends string = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n> =\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedToken;\n    } & ParsedCreateAssociatedTokenInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n    } & ParsedCreateAssociatedTokenIdempotentInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n    } & ParsedRecoverNestedAssociatedTokenInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/web3.js';\nimport {\n  type ParsedAmountToUiAmountInstruction,\n  type ParsedApproveCheckedInstruction,\n  type ParsedApproveInstruction,\n  type ParsedBurnCheckedInstruction,\n  type ParsedBurnInstruction,\n  type ParsedCloseAccountInstruction,\n  type ParsedFreezeAccountInstruction,\n  type ParsedGetAccountDataSizeInstruction,\n  type ParsedInitializeAccount2Instruction,\n  type ParsedInitializeAccount3Instruction,\n  type ParsedInitializeAccountInstruction,\n  type ParsedInitializeImmutableOwnerInstruction,\n  type ParsedInitializeMint2Instruction,\n  type ParsedInitializeMintInstruction,\n  type ParsedInitializeMultisig2Instruction,\n  type ParsedInitializeMultisigInstruction,\n  type ParsedMintToCheckedInstruction,\n  type ParsedMintToInstruction,\n  type ParsedRevokeInstruction,\n  type ParsedSetAuthorityInstruction,\n  type ParsedSyncNativeInstruction,\n  type ParsedThawAccountInstruction,\n  type ParsedTransferCheckedInstruction,\n  type ParsedTransferInstruction,\n  type ParsedUiAmountToAmountInstruction,\n} from '../instructions';\n\nexport const TOKEN_PROGRAM_ADDRESS =\n  'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n\nexport enum TokenAccount {\n  Mint,\n  Token,\n  Multisig,\n}\n\nexport function identifyTokenAccount(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): TokenAccount {\n  const data = 'data' in account ? account.data : account;\n  if (data.length === 82) {\n    return TokenAccount.Mint;\n  }\n  if (data.length === 165) {\n    return TokenAccount.Token;\n  }\n  if (data.length === 355) {\n    return TokenAccount.Multisig;\n  }\n  throw new Error(\n    'The provided account could not be identified as a token account.'\n  );\n}\n\nexport enum TokenInstruction {\n  InitializeMint,\n  InitializeAccount,\n  InitializeMultisig,\n  Transfer,\n  Approve,\n  Revoke,\n  SetAuthority,\n  MintTo,\n  Burn,\n  CloseAccount,\n  FreezeAccount,\n  ThawAccount,\n  TransferChecked,\n  ApproveChecked,\n  MintToChecked,\n  BurnChecked,\n  InitializeAccount2,\n  SyncNative,\n  InitializeAccount3,\n  InitializeMultisig2,\n  InitializeMint2,\n  GetAccountDataSize,\n  InitializeImmutableOwner,\n  AmountToUiAmount,\n  UiAmountToAmount,\n}\n\nexport function identifyTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): TokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return TokenInstruction.InitializeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return TokenInstruction.InitializeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return TokenInstruction.InitializeMultisig;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return TokenInstruction.Transfer;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return TokenInstruction.Approve;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return TokenInstruction.Revoke;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return TokenInstruction.SetAuthority;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return TokenInstruction.MintTo;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return TokenInstruction.Burn;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return TokenInstruction.CloseAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return TokenInstruction.FreezeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return TokenInstruction.ThawAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return TokenInstruction.TransferChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return TokenInstruction.ApproveChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return TokenInstruction.MintToChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return TokenInstruction.BurnChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return TokenInstruction.InitializeAccount2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return TokenInstruction.SyncNative;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return TokenInstruction.InitializeAccount3;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return TokenInstruction.InitializeMultisig2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return TokenInstruction.InitializeMint2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return TokenInstruction.GetAccountDataSize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return TokenInstruction.InitializeImmutableOwner;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return TokenInstruction.AmountToUiAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return TokenInstruction.UiAmountToAmount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a token instruction.'\n  );\n}\n\nexport type ParsedTokenInstruction<\n  TProgram extends string = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n> =\n  | ({\n      instructionType: TokenInstruction.InitializeMint;\n    } & ParsedInitializeMintInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount;\n    } & ParsedInitializeAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMultisig;\n    } & ParsedInitializeMultisigInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Transfer;\n    } & ParsedTransferInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Approve;\n    } & ParsedApproveInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Revoke;\n    } & ParsedRevokeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.SetAuthority;\n    } & ParsedSetAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.MintTo;\n    } & ParsedMintToInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Burn;\n    } & ParsedBurnInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.CloseAccount;\n    } & ParsedCloseAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.FreezeAccount;\n    } & ParsedFreezeAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.ThawAccount;\n    } & ParsedThawAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.TransferChecked;\n    } & ParsedTransferCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.ApproveChecked;\n    } & ParsedApproveCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.MintToChecked;\n    } & ParsedMintToCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.BurnChecked;\n    } & ParsedBurnCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount2;\n    } & ParsedInitializeAccount2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.SyncNative;\n    } & ParsedSyncNativeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount3;\n    } & ParsedInitializeAccount3Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMultisig2;\n    } & ParsedInitializeMultisig2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMint2;\n    } & ParsedInitializeMint2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.GetAccountDataSize;\n    } & ParsedGetAccountDataSizeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeImmutableOwner;\n    } & ParsedInitializeImmutableOwnerInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.AmountToUiAmount;\n    } & ParsedAmountToUiAmountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.UiAmountToAmount;\n    } & ParsedUiAmountToAmountInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidOwner: Associated token account owner does not match address derivation */\nexport const ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0x0; // 0\n\nexport type AssociatedTokenError = typeof ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;\n\nlet associatedTokenErrorMessages:\n  | Record<AssociatedTokenError, string>\n  | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`,\n  };\n}\n\nexport function getAssociatedTokenErrorMessage(\n  code: AssociatedTokenError\n): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (\n      associatedTokenErrorMessages as Record<AssociatedTokenError, string>\n    )[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isAssociatedTokenError<\n  TProgramErrorCode extends AssociatedTokenError,\n>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** NotRentExempt: Lamport balance below rent-exempt threshold */\nexport const TOKEN_ERROR__NOT_RENT_EXEMPT = 0x0; // 0\n/** InsufficientFunds: Insufficient funds */\nexport const TOKEN_ERROR__INSUFFICIENT_FUNDS = 0x1; // 1\n/** InvalidMint: Invalid Mint */\nexport const TOKEN_ERROR__INVALID_MINT = 0x2; // 2\n/** MintMismatch: Account not associated with this Mint */\nexport const TOKEN_ERROR__MINT_MISMATCH = 0x3; // 3\n/** OwnerMismatch: Owner does not match */\nexport const TOKEN_ERROR__OWNER_MISMATCH = 0x4; // 4\n/** FixedSupply: Fixed supply */\nexport const TOKEN_ERROR__FIXED_SUPPLY = 0x5; // 5\n/** AlreadyInUse: Already in use */\nexport const TOKEN_ERROR__ALREADY_IN_USE = 0x6; // 6\n/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */\nexport const TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 0x7; // 7\n/** InvalidNumberOfRequiredSigners: Invalid number of required signers */\nexport const TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 0x8; // 8\n/** UninitializedState: State is unititialized */\nexport const TOKEN_ERROR__UNINITIALIZED_STATE = 0x9; // 9\n/** NativeNotSupported: Instruction does not support native tokens */\nexport const TOKEN_ERROR__NATIVE_NOT_SUPPORTED = 0xa; // 10\n/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */\nexport const TOKEN_ERROR__NON_NATIVE_HAS_BALANCE = 0xb; // 11\n/** InvalidInstruction: Invalid instruction */\nexport const TOKEN_ERROR__INVALID_INSTRUCTION = 0xc; // 12\n/** InvalidState: State is invalid for requested operation */\nexport const TOKEN_ERROR__INVALID_STATE = 0xd; // 13\n/** Overflow: Operation overflowed */\nexport const TOKEN_ERROR__OVERFLOW = 0xe; // 14\n/** AuthorityTypeNotSupported: Account does not support specified authority type */\nexport const TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 0xf; // 15\n/** MintCannotFreeze: This token mint cannot freeze accounts */\nexport const TOKEN_ERROR__MINT_CANNOT_FREEZE = 0x10; // 16\n/** AccountFrozen: Account is frozen */\nexport const TOKEN_ERROR__ACCOUNT_FROZEN = 0x11; // 17\n/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */\nexport const TOKEN_ERROR__MINT_DECIMALS_MISMATCH = 0x12; // 18\n/** NonNativeNotSupported: Instruction does not support non-native tokens */\nexport const TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED = 0x13; // 19\n\nexport type TokenError =\n  | typeof TOKEN_ERROR__ACCOUNT_FROZEN\n  | typeof TOKEN_ERROR__ALREADY_IN_USE\n  | typeof TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__FIXED_SUPPLY\n  | typeof TOKEN_ERROR__INSUFFICIENT_FUNDS\n  | typeof TOKEN_ERROR__INVALID_INSTRUCTION\n  | typeof TOKEN_ERROR__INVALID_MINT\n  | typeof TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS\n  | typeof TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS\n  | typeof TOKEN_ERROR__INVALID_STATE\n  | typeof TOKEN_ERROR__MINT_CANNOT_FREEZE\n  | typeof TOKEN_ERROR__MINT_DECIMALS_MISMATCH\n  | typeof TOKEN_ERROR__MINT_MISMATCH\n  | typeof TOKEN_ERROR__NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__NON_NATIVE_HAS_BALANCE\n  | typeof TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__NOT_RENT_EXEMPT\n  | typeof TOKEN_ERROR__OVERFLOW\n  | typeof TOKEN_ERROR__OWNER_MISMATCH\n  | typeof TOKEN_ERROR__UNINITIALIZED_STATE;\n\nlet tokenErrorMessages: Record<TokenError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  tokenErrorMessages = {\n    [TOKEN_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_ERROR__UNINITIALIZED_STATE]: `State is unititialized`,\n  };\n}\n\nexport function getTokenErrorMessage(code: TokenError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (tokenErrorMessages as Record<TokenError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isTokenError<TProgramErrorCode extends TokenError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as web3JsIsTransactionSigner,\n  type Address,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/web3.js';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    web3JsIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\n\nexport function getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\n\nexport type AmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AmountToUiAmountInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to reformat. */\n  amount: bigint;\n};\n\nexport type AmountToUiAmountInstructionDataArgs = {\n  /** The amount of tokens to reformat. */\n  amount: number | bigint;\n};\n\nexport function getAmountToUiAmountInstructionDataEncoder(): Encoder<AmountToUiAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getAmountToUiAmountInstructionDataDecoder(): Decoder<AmountToUiAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getAmountToUiAmountInstructionDataCodec(): Codec<\n  AmountToUiAmountInstructionDataArgs,\n  AmountToUiAmountInstructionData\n> {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\n\nexport type AmountToUiAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  amount: AmountToUiAmountInstructionDataArgs['amount'];\n};\n\nexport function getAmountToUiAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: AmountToUiAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): AmountToUiAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args as AmountToUiAmountInstructionDataArgs\n    ),\n  } as AmountToUiAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedAmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: AmountToUiAmountInstructionData;\n};\n\nexport function parseAmountToUiAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAmountToUiAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_DISCRIMINATOR = 4;\n\nexport function getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\n\nexport type ApproveInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDelegate extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n};\n\nexport type ApproveInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n};\n\nexport function getApproveInstructionDataEncoder(): Encoder<ApproveInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveInstructionDataDecoder(): Decoder<ApproveInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getApproveInstructionDataCodec(): Codec<\n  ApproveInstructionDataArgs,\n  ApproveInstructionData\n> {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\n\nexport type ApproveInput<\n  TAccountSource extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveInstruction<\n  TAccountSource extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ApproveInput<TAccountSource, TAccountDelegate, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ApproveInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveInstructionDataEncoder().encode(\n      args as ApproveInstructionDataArgs\n    ),\n  } as ApproveInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The delegate. */\n    delegate: TAccountMetas[1];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ApproveInstructionData;\n};\n\nexport function parseApproveInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CHECKED_DISCRIMINATOR = 13;\n\nexport function getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\n\nexport type ApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDelegate extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ApproveCheckedInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getApproveCheckedInstructionDataEncoder(): Encoder<ApproveCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveCheckedInstructionDataDecoder(): Decoder<ApproveCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveCheckedInstructionDataCodec(): Codec<\n  ApproveCheckedInstructionDataArgs,\n  ApproveCheckedInstructionData\n> {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\n\nexport type ApproveCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveCheckedInstructionDataArgs['amount'];\n  decimals: ApproveCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ApproveCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args as ApproveCheckedInstructionDataArgs\n    ),\n  } as ApproveCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The delegate. */\n    delegate: TAccountMetas[2];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ApproveCheckedInstructionData;\n};\n\nexport function parseApproveCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_DISCRIMINATOR = 8;\n\nexport function getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\n\nexport type BurnInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnInstructionData = {\n  /** The amount of tokens to burn. */\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type BurnInstructionDataArgs = { amount: number | bigint };\n\nexport function getBurnInstructionDataEncoder(): Encoder<BurnInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnInstructionDataDecoder(): Decoder<BurnInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getBurnInstructionDataCodec(): Codec<\n  BurnInstructionDataArgs,\n  BurnInstructionData\n> {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\n\nexport type BurnInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: BurnInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnInstructionDataEncoder().encode(\n      args as BurnInstructionDataArgs\n    ),\n  } as BurnInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnInstructionData;\n};\n\nexport function parseBurnInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedBurnInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_CHECKED_DISCRIMINATOR = 15;\n\nexport function getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\n\nexport type BurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to burn. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type BurnCheckedInstructionDataArgs = {\n  /** The amount of tokens to burn. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getBurnCheckedInstructionDataEncoder(): Encoder<BurnCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnCheckedInstructionDataDecoder(): Decoder<BurnCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getBurnCheckedInstructionDataCodec(): Codec<\n  BurnCheckedInstructionDataArgs,\n  BurnCheckedInstructionData\n> {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\n\nexport type BurnCheckedInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnCheckedInstructionDataArgs['amount'];\n  decimals: BurnCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnCheckedInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: BurnCheckedInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnCheckedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args as BurnCheckedInstructionDataArgs\n    ),\n  } as BurnCheckedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnCheckedInstructionData;\n};\n\nexport function parseBurnCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedBurnCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_ACCOUNT_DISCRIMINATOR = 9;\n\nexport function getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseAccountInstructionData = { discriminator: number };\n\nexport type CloseAccountInstructionDataArgs = {};\n\nexport function getCloseAccountInstructionDataEncoder(): Encoder<CloseAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseAccountInstructionDataDecoder(): Decoder<CloseAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCloseAccountInstructionDataCodec(): Codec<\n  CloseAccountInstructionDataArgs,\n  CloseAccountInstructionData\n> {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\n\nexport type CloseAccountInput<\n  TAccountAccount extends string = string,\n  TAccountDestination extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to close. */\n  account: Address<TAccountAccount>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getCloseAccountInstruction<\n  TAccountAccount extends string,\n  TAccountDestination extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CloseAccountInput<TAccountAccount, TAccountDestination, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): CloseAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountDestination,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n  } as CloseAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountDestination,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to close. */\n    account: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: CloseAccountInstructionData;\n};\n\nexport function parseCloseAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCloseAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/web3.js';\n\nexport type AssociatedTokenSeeds = {\n  /** The wallet address of the associated token account. */\n  owner: Address;\n  /** The address of the token program to use. */\n  tokenProgram: Address;\n  /** The mint address of the associated token account. */\n  mint: Address;\n};\n\nexport async function findAssociatedTokenPda(\n  seeds: AssociatedTokenSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/web3.js';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\n\nexport function getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type CreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountAta extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenInstructionData = { discriminator: number };\n\nexport type CreateAssociatedTokenInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenInstructionDataEncoder(): Encoder<CreateAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenInstructionDataDecoder(): Decoder<CreateAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenInstructionDataCodec(): Codec<\n  CreateAssociatedTokenInstructionDataArgs,\n  CreateAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenInstructionData;\n};\n\nexport function parseCreateAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/web3.js';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\n\nexport function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountAta extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenIdempotentInstructionData = {\n  discriminator: number;\n};\n\nexport type CreateAssociatedTokenIdempotentInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): Encoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): Decoder<CreateAssociatedTokenIdempotentInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataCodec(): Codec<\n  CreateAssociatedTokenIdempotentInstructionDataArgs,\n  CreateAssociatedTokenIdempotentInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenIdempotentInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenIdempotentInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenIdempotentInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenIdempotentInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenIdempotentInstructionData;\n};\n\nexport function parseCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_ACCOUNT_DISCRIMINATOR = 10;\n\nexport function getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type FreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeAccountInstructionData = { discriminator: number };\n\nexport type FreezeAccountInstructionDataArgs = {};\n\nexport function getFreezeAccountInstructionDataEncoder(): Encoder<FreezeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeAccountInstructionDataDecoder(): Decoder<FreezeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getFreezeAccountInstructionDataCodec(): Codec<\n  FreezeAccountInstructionDataArgs,\n  FreezeAccountInstructionData\n> {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\n\nexport type FreezeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to freeze. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getFreezeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: FreezeAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n  } as FreezeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedFreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to freeze. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: FreezeAccountInstructionData;\n};\n\nexport function parseFreezeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedFreezeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\n\nexport function getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\n\nexport type GetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type GetAccountDataSizeInstructionData = { discriminator: number };\n\nexport type GetAccountDataSizeInstructionDataArgs = {};\n\nexport function getGetAccountDataSizeInstructionDataEncoder(): Encoder<GetAccountDataSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetAccountDataSizeInstructionDataDecoder(): Decoder<GetAccountDataSizeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getGetAccountDataSizeInstructionDataCodec(): Codec<\n  GetAccountDataSizeInstructionDataArgs,\n  GetAccountDataSizeInstructionData\n> {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\n\nexport type GetAccountDataSizeInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getGetAccountDataSizeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: GetAccountDataSizeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): GetAccountDataSizeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n  } as GetAccountDataSizeInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedGetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: GetAccountDataSizeInstructionData;\n};\n\nexport function parseGetAccountDataSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedGetAccountDataSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\n\nexport function getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccountInstructionData = { discriminator: number };\n\nexport type InitializeAccountInstructionDataArgs = {};\n\nexport function getInitializeAccountInstructionDataEncoder(): Encoder<InitializeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccountInstructionDataDecoder(): Decoder<InitializeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeAccountInstructionDataCodec(): Codec<\n  InitializeAccountInstructionDataArgs,\n  InitializeAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** The new account's owner/multisignature. */\n  owner: Address<TAccountOwner>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n};\n\nexport function getInitializeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccountInput<\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountOwner,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n  } as InitializeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** The new account's owner/multisignature. */\n    owner: TAccountMetas[2];\n    /** Rent sysvar. */\n    rent: TAccountMetas[3];\n  };\n  data: InitializeAccountInstructionData;\n};\n\nexport function parseInitializeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\n\nexport function getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\n\nexport type InitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount2InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount2InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount2InstructionDataEncoder(): Encoder<InitializeAccount2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount2InstructionDataDecoder(): Decoder<InitializeAccount2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount2InstructionDataCodec(): Codec<\n  InitializeAccount2InstructionDataArgs,\n  InitializeAccount2InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount2Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  owner: InitializeAccount2InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount2Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount2Input<TAccountAccount, TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount2Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args as InitializeAccount2InstructionDataArgs\n    ),\n  } as InitializeAccount2Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** Rent sysvar. */\n    rent: TAccountMetas[2];\n  };\n  data: InitializeAccount2InstructionData;\n};\n\nexport function parseInitializeAccount2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccount2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\n\nexport function getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\n\nexport type InitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount3InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount3InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount3InstructionDataEncoder(): Encoder<InitializeAccount3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount3InstructionDataDecoder(): Decoder<InitializeAccount3InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount3InstructionDataCodec(): Codec<\n  InitializeAccount3InstructionDataArgs,\n  InitializeAccount3InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount3Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  owner: InitializeAccount3InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount3Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount3Input<TAccountAccount, TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount3Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args as InitializeAccount3InstructionDataArgs\n    ),\n  } as InitializeAccount3Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n  };\n  data: InitializeAccount3InstructionData;\n};\n\nexport function parseInitializeAccount3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccount3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n    },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\n\nexport function getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\n\nexport type InitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeImmutableOwnerInstructionData = { discriminator: number };\n\nexport type InitializeImmutableOwnerInstructionDataArgs = {};\n\nexport function getInitializeImmutableOwnerInstructionDataEncoder(): Encoder<InitializeImmutableOwnerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeImmutableOwnerInstructionDataDecoder(): Decoder<InitializeImmutableOwnerInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeImmutableOwnerInstructionDataCodec(): Codec<\n  InitializeImmutableOwnerInstructionDataArgs,\n  InitializeImmutableOwnerInstructionData\n> {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeImmutableOwnerInput<\n  TAccountAccount extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getInitializeImmutableOwnerInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeImmutableOwnerInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n  } as InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n  };\n  data: InitializeImmutableOwnerInstructionData;\n};\n\nexport function parseInitializeImmutableOwnerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeImmutableOwnerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintInstructionData = {\n  discriminator: number;\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMintInstructionDataArgs = {\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintInstructionDataEncoder(): Encoder<InitializeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMintInstructionDataDecoder(): Decoder<InitializeMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintInstructionDataCodec(): Codec<\n  InitializeMintInstructionDataArgs,\n  InitializeMintInstructionData\n> {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintInput<\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Token mint account. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  decimals: InitializeMintInstructionDataArgs['decimals'];\n  mintAuthority: InitializeMintInstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMintInstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMintInstruction<\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintInput<TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    programAddress,\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args as InitializeMintInstructionDataArgs\n    ),\n  } as InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Token mint account. */\n    mint: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMintInstructionData;\n};\n\nexport function parseInitializeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT2_DISCRIMINATOR = 20;\n\nexport function getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\n\nexport type InitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMint2InstructionData = {\n  discriminator: number;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMint2InstructionDataArgs = {\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMint2InstructionDataEncoder(): Encoder<InitializeMint2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMint2InstructionDataDecoder(): Decoder<InitializeMint2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMint2InstructionDataCodec(): Codec<\n  InitializeMint2InstructionDataArgs,\n  InitializeMint2InstructionData\n> {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMint2Input<TAccountMint extends string = string> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  decimals: InitializeMint2InstructionDataArgs['decimals'];\n  mintAuthority: InitializeMint2InstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMint2InstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMint2Instruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMint2Input<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMint2Instruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args as InitializeMint2InstructionDataArgs\n    ),\n  } as InitializeMint2Instruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMint2InstructionData;\n};\n\nexport function parseInitializeMint2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMint2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\n\nexport function getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\n\nexport type InitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisigInstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisigInstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisigInstructionDataEncoder(): Encoder<InitializeMultisigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisigInstructionDataDecoder(): Decoder<InitializeMultisigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisigInstructionDataCodec(): Codec<\n  InitializeMultisigInstructionDataArgs,\n  InitializeMultisigInstructionData\n> {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisigInput<\n  TAccountMultisig extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The multisignature account to initialize. */\n  multisig: Address<TAccountMultisig>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  m: InitializeMultisigInstructionDataArgs['m'];\n  signers: Array<Address>;\n};\n\nexport function getInitializeMultisigInstruction<\n  TAccountMultisig extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisigInput<TAccountMultisig, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisigInstruction<\n  TProgramAddress,\n  TAccountMultisig,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args as InitializeMultisigInstructionDataArgs\n    ),\n  } as InitializeMultisigInstruction<\n    TProgramAddress,\n    TAccountMultisig,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMultisigInstructionData;\n};\n\nexport function parseInitializeMultisigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMultisigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\n\nexport function getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\n\nexport type InitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisig2InstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisig2InstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisig2InstructionDataEncoder(): Encoder<InitializeMultisig2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisig2InstructionDataDecoder(): Decoder<InitializeMultisig2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisig2InstructionDataCodec(): Codec<\n  InitializeMultisig2InstructionDataArgs,\n  InitializeMultisig2InstructionData\n> {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisig2Input<TAccountMultisig extends string = string> =\n  {\n    /** The multisignature account to initialize. */\n    multisig: Address<TAccountMultisig>;\n    m: InitializeMultisig2InstructionDataArgs['m'];\n    signers: Array<Address>;\n  };\n\nexport function getInitializeMultisig2Instruction<\n  TAccountMultisig extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisig2Input<TAccountMultisig>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    programAddress,\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args as InitializeMultisig2InstructionDataArgs\n    ),\n  } as InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n  };\n  data: InitializeMultisig2InstructionData;\n};\n\nexport function parseInitializeMultisig2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMultisig2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n    },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_DISCRIMINATOR = 7;\n\nexport function getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\n\nexport type MintToInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n};\n\nexport type MintToInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n};\n\nexport function getMintToInstructionDataEncoder(): Encoder<MintToInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToInstructionDataDecoder(): Decoder<MintToInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getMintToInstructionDataCodec(): Codec<\n  MintToInstructionDataArgs,\n  MintToInstructionData\n> {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\n\nexport type MintToInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint account. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: MintToInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        IAccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToInstructionDataEncoder().encode(\n      args as MintToInstructionDataArgs\n    ),\n  } as MintToInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          IAccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToInstructionData;\n};\n\nexport function parseMintToInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMintToInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_CHECKED_DISCRIMINATOR = 14;\n\nexport function getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\n\nexport type MintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type MintToCheckedInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getMintToCheckedInstructionDataEncoder(): Encoder<MintToCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToCheckedInstructionDataDecoder(): Decoder<MintToCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getMintToCheckedInstructionDataCodec(): Codec<\n  MintToCheckedInstructionDataArgs,\n  MintToCheckedInstructionData\n> {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\n\nexport type MintToCheckedInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToCheckedInstructionDataArgs['amount'];\n  decimals: MintToCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToCheckedInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: MintToCheckedInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToCheckedInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        IAccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args as MintToCheckedInstructionDataArgs\n    ),\n  } as MintToCheckedInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          IAccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToCheckedInstructionData;\n};\n\nexport function parseMintToCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMintToCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/web3.js';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\n\nexport function getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type RecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountNestedAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNestedTokenMintAddress extends string | IAccountMeta<string> = string,\n  TAccountDestinationAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountOwnerAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountOwnerTokenMintAddress extends string | IAccountMeta<string> = string,\n  TAccountWalletAddress extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNestedAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountNestedAssociatedAccountAddress>\n        : TAccountNestedAssociatedAccountAddress,\n      TAccountNestedTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountNestedTokenMintAddress>\n        : TAccountNestedTokenMintAddress,\n      TAccountDestinationAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountDestinationAssociatedAccountAddress>\n        : TAccountDestinationAssociatedAccountAddress,\n      TAccountOwnerAssociatedAccountAddress extends string\n        ? ReadonlyAccount<TAccountOwnerAssociatedAccountAddress>\n        : TAccountOwnerAssociatedAccountAddress,\n      TAccountOwnerTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountOwnerTokenMintAddress>\n        : TAccountOwnerTokenMintAddress,\n      TAccountWalletAddress extends string\n        ? WritableSignerAccount<TAccountWalletAddress> &\n            IAccountSignerMeta<TAccountWalletAddress>\n        : TAccountWalletAddress,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RecoverNestedAssociatedTokenInstructionData = {\n  discriminator: number;\n};\n\nexport type RecoverNestedAssociatedTokenInstructionDataArgs = {};\n\nexport function getRecoverNestedAssociatedTokenInstructionDataEncoder(): Encoder<RecoverNestedAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataDecoder(): Decoder<RecoverNestedAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataCodec(): Codec<\n  RecoverNestedAssociatedTokenInstructionDataArgs,\n  RecoverNestedAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type RecoverNestedAssociatedTokenAsyncInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress?: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress?: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress?: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getRecoverNestedAssociatedTokenInstructionAsync<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenAsyncInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value),\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type RecoverNestedAssociatedTokenInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getRecoverNestedAssociatedTokenInstruction<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): RecoverNestedAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountNestedAssociatedAccountAddress,\n  TAccountNestedTokenMintAddress,\n  TAccountDestinationAssociatedAccountAddress,\n  TAccountOwnerAssociatedAccountAddress,\n  TAccountOwnerTokenMintAddress,\n  TAccountWalletAddress,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n    nestedAssociatedAccountAddress: TAccountMetas[0];\n    /** Token mint for the nested associated token account. */\n    nestedTokenMintAddress: TAccountMetas[1];\n    /** Wallet's associated token account. */\n    destinationAssociatedAccountAddress: TAccountMetas[2];\n    /** Owner associated token account address, must be owned by `walletAddress`. */\n    ownerAssociatedAccountAddress: TAccountMetas[3];\n    /** Token mint for the owner associated token account. */\n    ownerTokenMintAddress: TAccountMetas[4];\n    /** Wallet address for the owner associated token account. */\n    walletAddress: TAccountMetas[5];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[6];\n  };\n  data: RecoverNestedAssociatedTokenInstructionData;\n};\n\nexport function parseRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRecoverNestedAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REVOKE_DISCRIMINATOR = 5;\n\nexport function getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\n\nexport type RevokeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RevokeInstructionData = { discriminator: number };\n\nexport type RevokeInstructionDataArgs = {};\n\nexport function getRevokeInstructionDataEncoder(): Encoder<RevokeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\n\nexport function getRevokeInstructionDataDecoder(): Decoder<RevokeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRevokeInstructionDataCodec(): Codec<\n  RevokeInstructionDataArgs,\n  RevokeInstructionData\n> {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\n\nexport type RevokeInput<\n  TAccountSource extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The source account owner or its multisignature. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getRevokeInstruction<\n  TAccountSource extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RevokeInput<TAccountSource, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): RevokeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getRevokeInstructionDataEncoder().encode({}),\n  } as RevokeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRevokeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The source account owner or its multisignature. */\n    owner: TAccountMetas[1];\n  };\n  data: RevokeInstructionData;\n};\n\nexport function parseRevokeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRevokeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorityTypeDecoder,\n  getAuthorityTypeEncoder,\n  type AuthorityType,\n  type AuthorityTypeArgs,\n} from '../types';\n\nexport const SET_AUTHORITY_DISCRIMINATOR = 6;\n\nexport function getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type SetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountOwned extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountOwned extends string\n        ? WritableAccount<TAccountOwned>\n        : TAccountOwned,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetAuthorityInstructionData = {\n  discriminator: number;\n  /** The type of authority to update. */\n  authorityType: AuthorityType;\n  /** The new authority */\n  newAuthority: Option<Address>;\n};\n\nexport type SetAuthorityInstructionDataArgs = {\n  /** The type of authority to update. */\n  authorityType: AuthorityTypeArgs;\n  /** The new authority */\n  newAuthority: OptionOrNullable<Address>;\n};\n\nexport function getSetAuthorityInstructionDataEncoder(): Encoder<SetAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['authorityType', getAuthorityTypeEncoder()],\n      ['newAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetAuthorityInstructionDataDecoder(): Decoder<SetAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['authorityType', getAuthorityTypeDecoder()],\n    ['newAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetAuthorityInstructionDataCodec(): Codec<\n  SetAuthorityInstructionDataArgs,\n  SetAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetAuthorityInput<\n  TAccountOwned extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The mint or account to change the authority of. */\n  owned: Address<TAccountOwned>;\n  /** The current authority or the multisignature account of the mint or account to update. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  authorityType: SetAuthorityInstructionDataArgs['authorityType'];\n  newAuthority: SetAuthorityInstructionDataArgs['newAuthority'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetAuthorityInstruction<\n  TAccountOwned extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: SetAuthorityInput<TAccountOwned, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): SetAuthorityInstruction<\n  TProgramAddress,\n  TAccountOwned,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args as SetAuthorityInstructionDataArgs\n    ),\n  } as SetAuthorityInstruction<\n    TProgramAddress,\n    TAccountOwned,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint or account to change the authority of. */\n    owned: TAccountMetas[0];\n    /** The current authority or the multisignature account of the mint or account to update. */\n    owner: TAccountMetas[1];\n  };\n  data: SetAuthorityInstructionData;\n};\n\nexport function parseSetAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      owned: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SYNC_NATIVE_DISCRIMINATOR = 17;\n\nexport function getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\n\nexport type SyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SyncNativeInstructionData = { discriminator: number };\n\nexport type SyncNativeInstructionDataArgs = {};\n\nexport function getSyncNativeInstructionDataEncoder(): Encoder<SyncNativeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\n\nexport function getSyncNativeInstructionDataDecoder(): Decoder<SyncNativeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getSyncNativeInstructionDataCodec(): Codec<\n  SyncNativeInstructionDataArgs,\n  SyncNativeInstructionData\n> {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\n\nexport type SyncNativeInput<TAccountAccount extends string = string> = {\n  /** The native token account to sync with its underlying lamports. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getSyncNativeInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: SyncNativeInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): SyncNativeInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n  } as SyncNativeInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedSyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The native token account to sync with its underlying lamports. */\n    account: TAccountMetas[0];\n  };\n  data: SyncNativeInstructionData;\n};\n\nexport function parseSyncNativeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSyncNativeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const THAW_ACCOUNT_DISCRIMINATOR = 11;\n\nexport function getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type ThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ThawAccountInstructionData = { discriminator: number };\n\nexport type ThawAccountInstructionDataArgs = {};\n\nexport function getThawAccountInstructionDataEncoder(): Encoder<ThawAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getThawAccountInstructionDataDecoder(): Decoder<ThawAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getThawAccountInstructionDataCodec(): Codec<\n  ThawAccountInstructionDataArgs,\n  ThawAccountInstructionData\n> {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\n\nexport type ThawAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to thaw. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getThawAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ThawAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ThawAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getThawAccountInstructionDataEncoder().encode({}),\n  } as ThawAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to thaw. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ThawAccountInstructionData;\n};\n\nexport function parseThawAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedThawAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_DISCRIMINATOR = 3;\n\nexport function getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\n\nexport type TransferInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n};\n\nexport type TransferInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n};\n\nexport function getTransferInstructionDataEncoder(): Encoder<TransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferInstructionDataDecoder(): Decoder<TransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferInstructionDataCodec(): Codec<\n  TransferInstructionDataArgs,\n  TransferInstructionData\n> {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\n\nexport type TransferInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: TransferInput<TAccountSource, TAccountDestination, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): TransferInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferInstructionDataEncoder().encode(\n      args as TransferInstructionDataArgs\n    ),\n  } as TransferInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: TransferInstructionData;\n};\n\nexport function parseTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_DISCRIMINATOR = 12;\n\nexport function getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\n\nexport type TransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type TransferCheckedInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getTransferCheckedInstructionDataEncoder(): Encoder<TransferCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferCheckedInstructionDataDecoder(): Decoder<TransferCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedInstructionDataCodec(): Codec<\n  TransferCheckedInstructionDataArgs,\n  TransferCheckedInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedInstructionDataArgs['amount'];\n  decimals: TransferCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args as TransferCheckedInstructionDataArgs\n    ),\n  } as TransferCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The destination account. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedInstructionData;\n};\n\nexport function parseTransferCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\n\nexport function getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\n\nexport type UiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UiAmountToAmountInstructionData = {\n  discriminator: number;\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport type UiAmountToAmountInstructionDataArgs = {\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport function getUiAmountToAmountInstructionDataEncoder(): Encoder<UiAmountToAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['uiAmount', getUtf8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getUiAmountToAmountInstructionDataDecoder(): Decoder<UiAmountToAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['uiAmount', getUtf8Decoder()],\n  ]);\n}\n\nexport function getUiAmountToAmountInstructionDataCodec(): Codec<\n  UiAmountToAmountInstructionDataArgs,\n  UiAmountToAmountInstructionData\n> {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\n\nexport type UiAmountToAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  uiAmount: UiAmountToAmountInstructionDataArgs['uiAmount'];\n};\n\nexport function getUiAmountToAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: UiAmountToAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): UiAmountToAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args as UiAmountToAmountInstructionDataArgs\n    ),\n  } as UiAmountToAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedUiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: UiAmountToAmountInstructionData;\n};\n\nexport function parseUiAmountToAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUiAmountToAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n"]}