import{box as e,randomBytes as s}from"tweetnacl";import{encodeBase64 as t,decodeUTF8 as i,decodeBase64 as r,encodeUTF8 as n}from"tweetnacl-util";import{isResponseError as o,EventType as c}from"./interfaces.js";import{Subject as a,timer as l,takeUntil as p,take as h,firstValueFrom as u,switchMap as d,throwError as b,of as g}from"rxjs";import{xBullSDK as m}from"./mobile-sdk.js";class w{constructor(o){this.closeCurrentPromises$=new a,this.closeObservables$=new a,this.initialResponse$=new a,this.initialResponseCompleted$=new a,this.connectResponse$=new a,this.connectResult$=new a,this.signResponse$=new a,this.signResult$=new a,this.closeCurrentPromisesSubscription=l(1e3,1e3).pipe(p(this.closeObservables$)).subscribe((()=>{this.target?.closed&&this.closeCurrentPromises$.next()})),this.onInititalResponseSubscription=this.initialResponse$.pipe(p(this.closeObservables$)).subscribe((e=>{const s=this.decryptFromReceiver({oneTimeCode:e.data.oneTimeCode,payload:e.data.message,senderPublicKey:e.data.publicKey});JSON.parse(s).providedSession===this.session()&&(this.targetPublicKey=e.data.publicKey,this.initialResponseCompleted$.next())})),this.onConnectResponseSubscription=this.connectResponse$.pipe(p(this.closeObservables$)).subscribe((e=>{if(!this.targetPublicKey)return void this.connectResult$.next({success:!1,message:"Wallet encryption public key is not provided, request rejected."});if(!e.data.success)return void this.connectResult$.next({success:!1,message:"Request rejected from the wallet"});const s=this.decryptFromReceiver({oneTimeCode:e.data.oneTimeCode,payload:e.data.message,senderPublicKey:this.targetPublicKey}),t=JSON.parse(s);this.connectResult$.next({success:!0,publicKey:t.publicKey})})),this.onSignResponseSubscription=this.signResponse$.pipe(p(this.closeObservables$)).subscribe((e=>{if(!this.targetPublicKey)return void this.signResult$.next({success:!1,message:"Wallet encryption public key is not provided, request rejected."});if(!e.data.success)return void this.signResult$.next({success:!1,message:"Request rejected from the wallet"});const s=this.decryptFromReceiver({oneTimeCode:e.data.oneTimeCode,payload:e.data.message,senderPublicKey:this.targetPublicKey}),t=JSON.parse(s);this.signResult$.next({success:!0,xdr:t.xdr})})),this.preferredTarget=o?.preferredTarget||"extension",this.walletUrl=o?.url||"https://wallet.xbull.app/connect";const u=e.keyPair(),d=t(s(24));this.encryptForReceiver=r=>{const n=s(24),o=e(i(r.data),n,r.receiverPublicKey,u.secretKey);return{message:t(o),oneTimeCode:t(n)}},this.decryptFromReceiver=s=>{const t=e.open(r(s.payload),r(s.oneTimeCode),r(s.senderPublicKey),u.secretKey);if(!t)throw new Error("Decrypted message is null");return n(t)},this.publicKey=()=>u.publicKey,this.session=()=>d.slice();const b=e=>{switch(e.data.type){case c.XBULL_INITIAL_RESPONSE:this.initialResponse$.next(e);break;case c.XBULL_CONNECT_RESPONSE:this.connectResponse$.next(e);break;case c.XBULL_SIGN_RESPONSE:this.signResponse$.next(e)}};window.addEventListener("message",b),this.closeObservables$.asObservable().pipe(h(1)).subscribe((()=>{window.removeEventListener("message",b)}))}openWallet(){return this.target&&!this.target.closed&&(this.target.close(),this.target=null,this.closeCurrentPromises$.next()),this.target=window.open(`${this.walletUrl}?public=${encodeURIComponent(t(this.publicKey()))}&session=${encodeURIComponent(this.session())}`,"xBull_Wallet_app","width=380,height=640,left=100,top=100"),u(this.initialResponseCompleted$.pipe(p(this.closeCurrentPromises$)).pipe(p(this.closeObservables$)))}closeWallet(){this.target&&(this.target?.close(),this.target=null)}async connect(e={canRequestPublicKey:!0,canRequestSign:!0}){const s=window?.webkit?.messageHandlers?.cordova_iab?new m:window.xBullSDK;if(s&&"extension"===this.preferredTarget){const e=await s.getAddress();if(o(e))throw e.error;return e.address}{if(await this.openWallet(),!this.target||!this.targetPublicKey)throw new Error("xBull Wallet is not open, we can't connect with it");const{message:s,oneTimeCode:t}=this.encryptForReceiver({data:JSON.stringify(e),receiverPublicKey:r(this.targetPublicKey)}),i={type:c.XBULL_CONNECT,message:s,oneTimeCode:t};this.target.postMessage(i,"*");const n=this.connectResult$.asObservable().pipe(d((e=>e.success?(this.closeWallet(),g(e.publicKey)):(this.closeWallet(),b((()=>new Error(e.message))))))).pipe(h(1)).pipe(p(this.closeCurrentPromises$)).pipe(p(this.closeObservables$));return u(n)}}async sign(e){const s=window?.webkit?.messageHandlers?.cordova_iab?new m:window.xBullSDK;if(s&&"extension"===this.preferredTarget){const t=await s.signTransaction({xdr:e.xdr,opts:{networkPassphrase:e.network,address:e.publicKey}});if(o(t))throw t.error;return t.signedTxXdr}{if(await this.openWallet(),!this.target||!this.targetPublicKey)throw new Error("xBull Wallet is not open, we can't connect with it");if("string"!=typeof e.xdr)throw new Error("XDR provided needs to be a string value");const{message:s,oneTimeCode:t}=this.encryptForReceiver({data:JSON.stringify(e),receiverPublicKey:r(this.targetPublicKey)}),i={type:c.XBULL_SIGN,message:s,oneTimeCode:t};this.target.postMessage(i,"*");const n=this.signResult$.asObservable().pipe(d((e=>e.success?(this.closeWallet(),g(e.xdr)):(this.closeWallet(),b((()=>new Error(e.message))))))).pipe(h(1)).pipe(p(this.closeCurrentPromises$)).pipe(p(this.closeObservables$));return u(n)}}closeConnections(){this.closeObservables$.next(),this.closeCurrentPromises$.next(),this.closeObservables$.complete(),this.closeCurrentPromises$.complete()}}export{w as xBullWalletConnect};
//# sourceMappingURL=index.js.map
