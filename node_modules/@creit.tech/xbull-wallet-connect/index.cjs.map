{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["import { box, randomBytes } from 'tweetnacl';\nimport { decodeBase64, decodeUTF8, encodeBase64, encodeUTF8 } from 'tweetnacl-util';\nimport {\n  EventType,\n  IConnectParams,\n  IConnectRequestData,\n  IConnectResponseData,\n  IConnectResult,\n  InitialResponseListenerData,\n  IRejectResponse,\n  IRejectResult,\n  ISDKConstructor,\n  ISignParams, ISignRequestData,\n  ISignResponseData,\n  ISignResult,\n  isResponseError,\n  SdkResponse,\n} from './interfaces';\nimport {\n  firstValueFrom,\n  of,\n  Subject,\n  Subscription,\n  switchMap,\n  take,\n  takeUntil,\n  throwError,\n  timer\n} from 'rxjs';\nimport { xBullSDK } from './mobile-sdk';\n\nexport class xBullWalletConnect {\n  closeCurrentPromises$: Subject<void> = new Subject<void>();\n  closeObservables$: Subject<void> = new Subject<void>();\n\n  preferredTarget: Required<ISDKConstructor['preferredTarget']>;\n\n  target?: Window | null;\n  targetPublicKey?: string; // this value is encrypted\n  readonly walletUrl: string;\n\n  encryptForReceiver: (params: { data: string, receiverPublicKey: Uint8Array }) => { message: string, oneTimeCode: string };\n  decryptFromReceiver: (params: { payload: string; oneTimeCode: string; senderPublicKey: string }) => string;\n  publicKey: () => Uint8Array;\n  session: () => string;\n\n  initialResponse$: Subject<MessageEvent<InitialResponseListenerData>> = new Subject<MessageEvent<InitialResponseListenerData>>();\n  initialResponseCompleted$: Subject<void> = new Subject<void>();\n\n  connectResponse$: Subject<MessageEvent<IConnectResponseData | IRejectResponse>> = new Subject<MessageEvent<IConnectResponseData | IRejectResponse>>();\n  connectResult$: Subject<IConnectResult | IRejectResult> = new Subject<IConnectResult | IRejectResult>(); // the value is the public key returned from the wallet\n\n  signResponse$: Subject<MessageEvent<ISignResponseData | IRejectResponse>> = new Subject<MessageEvent<ISignResponseData | IRejectResponse>>();\n  signResult$: Subject<ISignResult | IRejectResult> = new Subject<ISignResult | IRejectResult>();\n\n  constructor(params?: ISDKConstructor) {\n    this.preferredTarget = params?.preferredTarget || 'extension';\n    this.walletUrl = params?.url || 'https://wallet.xbull.app/connect';\n    const sessionKeypair = box.keyPair();\n    const session = encodeBase64(randomBytes(24));\n\n    this.encryptForReceiver = (params: { data: string, receiverPublicKey: Uint8Array }) => {\n      const oneTimeCode = randomBytes(24);\n      const cipherText = box(\n        decodeUTF8(params.data),\n        oneTimeCode,\n        params.receiverPublicKey,\n        sessionKeypair.secretKey\n      );\n\n      return {\n        message: encodeBase64(cipherText),\n        oneTimeCode: encodeBase64(oneTimeCode),\n      };\n    };\n\n    this.decryptFromReceiver = (params: { payload: string; oneTimeCode: string; senderPublicKey: string }) => {\n      const decryptedMessage = box.open(\n        decodeBase64(params.payload),\n        decodeBase64(params.oneTimeCode),\n        decodeBase64(params.senderPublicKey),\n        sessionKeypair.secretKey,\n      );\n\n      if (!decryptedMessage) {\n        throw new Error('Decrypted message is null');\n      }\n\n      return encodeUTF8(decryptedMessage);\n    }\n\n    this.publicKey = () => sessionKeypair.publicKey;\n\n    this.session = () => session.slice();\n\n    const listener = (ev: any) => {\n      switch (ev.data.type as EventType) {\n        case EventType.XBULL_INITIAL_RESPONSE:\n          this.initialResponse$.next(ev);\n          break;\n\n        case EventType.XBULL_CONNECT_RESPONSE:\n          this.connectResponse$.next(ev);\n          break;\n\n        case EventType.XBULL_SIGN_RESPONSE:\n          this.signResponse$.next(ev);\n          break;\n      }\n    };\n\n    window.addEventListener('message', listener);\n\n    this.closeObservables$.asObservable()\n      .pipe(take(1))\n      .subscribe(() => {\n        window.removeEventListener('message', listener);\n      });\n  }\n\n  closeCurrentPromisesSubscription: Subscription = timer(1000, 1000)\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe(() => {\n      if (this.target?.closed) {\n        this.closeCurrentPromises$.next();\n      }\n    })\n\n  onInititalResponseSubscription: Subscription = this.initialResponse$\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe((ev: MessageEvent<InitialResponseListenerData>) => {\n      const decryptedMessage = this.decryptFromReceiver({\n        oneTimeCode: ev.data.oneTimeCode,\n        payload: ev.data.message,\n        senderPublicKey: ev.data.publicKey\n      });\n\n      const data = JSON.parse(decryptedMessage);\n\n      if (data.providedSession === this.session()) {\n        this.targetPublicKey = ev.data.publicKey;\n        this.initialResponseCompleted$.next();\n      }\n    });\n\n  onConnectResponseSubscription: Subscription = this.connectResponse$\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe((ev: MessageEvent<IConnectResponseData | IRejectResponse>) => {\n      if (!this.targetPublicKey) {\n        this.connectResult$.next({ success: false, message: 'Wallet encryption public key is not provided, request rejected.' })\n        return;\n      }\n\n      if (!ev.data.success) {\n        this.connectResult$.next({ success: false, message: 'Request rejected from the wallet' });\n        return;\n      }\n\n      const decryptedMessage = this.decryptFromReceiver({\n        oneTimeCode: ev.data.oneTimeCode,\n        payload: ev.data.message,\n        senderPublicKey: this.targetPublicKey,\n      });\n\n      const data: { publicKey: string } = JSON.parse(decryptedMessage);\n\n      this.connectResult$.next({ success: true, publicKey: data.publicKey });\n    });\n\n  onSignResponseSubscription: Subscription = this.signResponse$\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe((ev: MessageEvent<ISignResponseData | IRejectResponse>) => {\n      if (!this.targetPublicKey) {\n        this.signResult$.next({ success: false, message: 'Wallet encryption public key is not provided, request rejected.' })\n        return;\n      }\n\n      if (!ev.data.success) {\n        this.signResult$.next({ success: false, message: 'Request rejected from the wallet' });\n        return;\n      }\n\n      const decryptedMessage = this.decryptFromReceiver({\n        oneTimeCode: ev.data.oneTimeCode,\n        payload: ev.data.message,\n        senderPublicKey: this.targetPublicKey,\n      });\n\n      const data: { xdr: string } = JSON.parse(decryptedMessage);\n\n      this.signResult$.next({ success: true, xdr: data.xdr });\n    });\n\n  openWallet() {\n    if (!!this.target && !this.target.closed) {\n      this.target.close();\n      this.target = null;\n      this.closeCurrentPromises$.next();\n    }\n\n    this.target = window.open(\n      `${this.walletUrl}?public=${encodeURIComponent(encodeBase64(this.publicKey()))}&session=${encodeURIComponent(this.session())}`,\n      'xBull_Wallet_app',\n      'width=380,height=640,left=100,top=100'\n    );\n\n    return firstValueFrom(\n      this.initialResponseCompleted$\n        .pipe(takeUntil(this.closeCurrentPromises$))\n        .pipe(takeUntil(this.closeObservables$))\n    );\n  }\n\n  closeWallet() {\n    if (!!this.target) {\n      this.target?.close();\n      this.target = null;\n    }\n  }\n\n  async connect(params: IConnectParams = { canRequestPublicKey: true, canRequestSign: true }): Promise<string> {\n    const extensionSdk: xBullSDK = !!(window as any)?.webkit?.messageHandlers?.cordova_iab ? new xBullSDK() : (window as any).xBullSDK;\n    if (!!extensionSdk && this.preferredTarget === 'extension') {\n      const response: SdkResponse<{ address: string }> = await extensionSdk.getAddress();\n\n      if (isResponseError(response)) {\n        throw response.error;\n      } else {\n        return response.address;\n      }\n    } else {\n\n      await this.openWallet();\n\n      if (!this.target || !this.targetPublicKey) {\n        throw new Error(`xBull Wallet is not open, we can't connect with it`);\n      }\n\n      const { message, oneTimeCode } = this.encryptForReceiver({\n        data: JSON.stringify(params),\n        receiverPublicKey: decodeBase64(this.targetPublicKey),\n      })\n\n      const payload: IConnectRequestData = {\n        type: EventType.XBULL_CONNECT,\n        message,\n        oneTimeCode,\n      };\n\n      this.target.postMessage(payload, '*');\n\n      const result = this.connectResult$\n        .asObservable()\n        .pipe(switchMap(result => {\n          if (!result.success) {\n            this.closeWallet();\n            return throwError(() => new Error(result.message));\n          } else {\n            this.closeWallet();\n            return of(result.publicKey);\n          }\n        }))\n        .pipe(take(1))\n        .pipe(takeUntil(this.closeCurrentPromises$))\n        .pipe(takeUntil(this.closeObservables$));\n\n      return firstValueFrom(result);\n\n    }\n  }\n\n  async sign(params: ISignParams): Promise<string> {\n    const extensionSdk: xBullSDK = !!(window as any)?.webkit?.messageHandlers?.cordova_iab ? new xBullSDK() : (window as any).xBullSDK;\n    if (!!extensionSdk && this.preferredTarget === 'extension') {\n      const response = await extensionSdk.signTransaction({\n        xdr: params.xdr,\n        opts: {\n          networkPassphrase: params.network,\n          address: params.publicKey,\n        }\n      });\n\n      if (isResponseError(response)) {\n        throw response.error;\n      } else {\n        return response.signedTxXdr;\n      }\n    } else {\n      await this.openWallet();\n\n      if (!this.target || !this.targetPublicKey) {\n        throw new Error(`xBull Wallet is not open, we can't connect with it`);\n      }\n\n      if (typeof params.xdr !== 'string') {\n        throw new Error('XDR provided needs to be a string value');\n      }\n\n      const { message, oneTimeCode } = this.encryptForReceiver({\n        data: JSON.stringify(params),\n        receiverPublicKey: decodeBase64(this.targetPublicKey),\n      });\n\n      const payload: ISignRequestData = {\n        type: EventType.XBULL_SIGN,\n        message,\n        oneTimeCode,\n      };\n\n      this.target.postMessage(payload, '*');\n\n      const result = this.signResult$\n        .asObservable()\n        .pipe(switchMap(result => {\n          if (!result.success) {\n            this.closeWallet();\n            return throwError(() => new Error(result.message));\n          } else {\n            this.closeWallet();\n            return of(result.xdr);\n          }\n        }))\n        .pipe(take(1))\n        .pipe(takeUntil(this.closeCurrentPromises$))\n        .pipe(takeUntil(this.closeObservables$));\n\n      return firstValueFrom(result);\n    }\n  }\n\n  closeConnections() {\n    this.closeObservables$.next();\n    this.closeCurrentPromises$.next();\n    this.closeObservables$.complete();\n    this.closeCurrentPromises$.complete();\n  }\n}\n"],"names":["constructor","params","this","closeCurrentPromises$","Subject","closeObservables$","initialResponse$","initialResponseCompleted$","connectResponse$","connectResult$","signResponse$","signResult$","closeCurrentPromisesSubscription","timer","pipe","takeUntil","subscribe","target","closed","next","onInititalResponseSubscription","ev","decryptedMessage","decryptFromReceiver","oneTimeCode","data","payload","message","senderPublicKey","publicKey","JSON","parse","providedSession","session","targetPublicKey","onConnectResponseSubscription","success","onSignResponseSubscription","xdr","preferredTarget","walletUrl","url","sessionKeypair","box","keyPair","encodeBase64","randomBytes","encryptForReceiver","cipherText","decodeUTF8","receiverPublicKey","secretKey","open","decodeBase64","Error","encodeUTF8","slice","listener","type","EventType","XBULL_INITIAL_RESPONSE","XBULL_CONNECT_RESPONSE","XBULL_SIGN_RESPONSE","window","addEventListener","asObservable","take","removeEventListener","openWallet","close","encodeURIComponent","firstValueFrom","closeWallet","connect","canRequestPublicKey","canRequestSign","extensionSdk","webkit","messageHandlers","cordova_iab","xBullSDK","response","getAddress","isResponseError","error","address","stringify","XBULL_CONNECT","postMessage","result","switchMap","of","throwError","sign","signTransaction","opts","networkPassphrase","network","signedTxXdr","XBULL_SIGN","closeConnections","complete"],"mappings":"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"}