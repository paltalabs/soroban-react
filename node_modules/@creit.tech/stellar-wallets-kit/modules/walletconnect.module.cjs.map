{"version":3,"file":"walletconnect.module.cjs","sources":["../../src/modules/walletconnect.module.ts"],"sourcesContent":["import { WalletConnectModal } from '@walletconnect/modal';\nimport { SignClient } from '@walletconnect/sign-client';\nimport { ISignClient } from '@walletconnect/types/dist/types/sign-client/client';\nimport { SessionTypes } from '@walletconnect/types/dist/types/sign-client/session';\nimport { ModuleInterface, ModuleType, WalletNetwork } from '../types';\nimport { parseError } from '../utils';\n\nconst parseWalletConnectSession = (session: SessionTypes.Struct): IParsedWalletConnectSession => {\n  const accounts = session.namespaces.stellar.accounts.map((account: string) => ({\n    network: account.split(':')[1] as 'pubnet' | 'testnet',\n    publicKey: account.split(':')[2],\n  }));\n\n  return {\n    id: session.topic,\n    name: session.peer.metadata.name,\n    description: session.peer.metadata.description,\n    url: session.peer.metadata.url,\n    icons: session.peer.metadata.icons[0],\n    accounts,\n  };\n};\n\nexport interface IParsedWalletConnectSession {\n  // \"id\" is the topic, we call it \"id\" to make it easier for those not familiarized with WalletConnect\n  id: string;\n  name: string;\n  description: string;\n  url: string;\n  icons: string;\n  accounts: Array<{\n    network: 'pubnet' | 'testnet';\n    publicKey: string;\n  }>;\n}\n\nexport const WALLET_CONNECT_ID = 'wallet_connect';\n\nexport class WalletConnectModule implements ModuleInterface {\n  moduleType: ModuleType = ModuleType.BRIDGE_WALLET;\n\n  productId: string = WALLET_CONNECT_ID;\n  productName: string = 'Wallet Connect';\n  productUrl: string = 'https://walletconnect.com/';\n  productIcon: string = 'https://stellar.creit.tech/wallet-icons/walletconnect.png';\n\n  private client?: ISignClient & {\n    on: (event: string, cb: (data: { topic: string }) => void) => void;\n  };\n  private activeSession?: string;\n  private qrModal!: WalletConnectModal;\n\n  async isAvailable(): Promise<boolean> {\n    return true;\n  }\n\n  constructor(public wcParams: IWalletConnectConstructorParams) {\n    if (wcParams.sessionId) {\n      this.setSession(wcParams.sessionId);\n    }\n\n    if (wcParams.client && wcParams.modal) {\n      this.client = wcParams.client as any;\n      this.qrModal = wcParams.modal;\n    } else {\n      SignClient.init({\n        projectId: wcParams.projectId,\n        metadata: {\n          name: wcParams.name,\n          url: wcParams.url,\n          description: wcParams.description,\n          icons: wcParams.icons,\n        },\n      })\n        .then(client => {\n          console.log('WalletConnect is ready.');\n          this.client = client as never;\n          this.qrModal = new WalletConnectModal({ projectId: wcParams.projectId });\n\n          if (wcParams.onSessionDeleted) {\n            this.onSessionDeleted(wcParams.onSessionDeleted);\n          }\n        })\n        .catch(console.error);\n    }\n  }\n\n  async getAddress(): Promise<{ address: string }> {\n    const runChecks = async () => {\n      if (!this.client) {\n        throw new Error('WalletConnect is not running yet');\n      }\n    };\n\n    return runChecks()\n      .then(async (): Promise<{ address: string }> => {\n        const targetSession: IParsedWalletConnectSession = await this.getTargetSession();\n        return { address: targetSession.accounts[0].publicKey };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signTransaction(\n    xdr: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n      submit?: boolean;\n      submitUrl?: string;\n    }\n  ): Promise<{ signedTxXdr: string; signerAddress?: string }> {\n    const runChecks = async () => {\n      if (!this.client) {\n        throw new Error('WalletConnect is not running yet');\n      }\n    };\n\n    return runChecks()\n      .then(async () => {\n        const targetSession: IParsedWalletConnectSession = await this.getTargetSession({ publicKey: opts?.address });\n        const signedTxXdr = await this.client!.request({\n          topic: targetSession.id,\n          chainId:\n            opts?.networkPassphrase === WalletNetwork.PUBLIC\n              ? WalletConnectTargetChain.PUBLIC\n              : WalletConnectTargetChain.TESTNET,\n          request: {\n            method: this.wcParams.method,\n            params: { xdr },\n          },\n        }).then((v: any) => v.signedXDR);\n\n        return { signedTxXdr };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signAuthEntry(): Promise<{ signedAuthEntry: string; signerAddress?: string }> {\n    throw {\n      code: -3,\n      message: 'WalletConnect does not support the \"signAuthEntry\" function',\n    };\n  }\n\n  async signMessage(): Promise<{ signedMessage: string; signerAddress?: string }> {\n    throw {\n      code: -3,\n      message: 'WalletConnect does not support the \"signMessage\" function',\n    };\n  }\n\n  async getNetwork(): Promise<{ network: string; networkPassphrase: string }> {\n    throw {\n      code: -3,\n      message: 'WalletConnect does not support the \"getNetwork\" function',\n    };\n  }\n\n  /**\n   * Allows manually setting the current active session to be used in the kit when doing WalletConnect requests\n   *\n   * @param sessionId The session ID is a placeholder for the session \"topic\", term used in WalletConnect\n   * */\n  public setSession(sessionId: string) {\n    this.activeSession = sessionId;\n  }\n\n  public onSessionDeleted(cb: (sessionId: string) => void) {\n    if (!this.client) {\n      throw new Error('WalletConnect is not running yet');\n    }\n\n    this.client.on('session_delete', data => {\n      cb(data.topic);\n    });\n  }\n\n  public async connectWalletConnect(): Promise<IParsedWalletConnectSession> {\n    if (!this.client) {\n      throw new Error('WalletConnect is not running yet');\n    }\n\n    try {\n      const { uri, approval } = await this.client.connect({\n        requiredNamespaces: {\n          stellar: {\n            methods: [this.wcParams.method],\n            chains: [\n              this.wcParams.network === WalletNetwork.PUBLIC\n                ? WalletConnectTargetChain.PUBLIC\n                : WalletConnectTargetChain.TESTNET,\n            ],\n            events: [],\n          },\n        },\n      });\n      const session: IParsedWalletConnectSession = await new Promise<SessionTypes.Struct>((resolve, reject) => {\n        // Open QRCode modal if a URI was returned (i.e. we're not connecting an existing pairing).\n        if (uri) {\n          this.qrModal.openModal({ uri });\n        }\n\n        // Await session approval from the wallet.\n        approval()\n          .then(session => {\n            this.qrModal.closeModal();\n            resolve(session);\n          })\n          .catch(error => {\n            this.qrModal.closeModal();\n            reject(error);\n          });\n      }).then(parseWalletConnectSession);\n\n      this.setSession(session.id);\n      return session;\n    } catch (e: unknown) {\n      this.qrModal.closeModal();\n      console.error(e);\n      throw new Error('There was an error when trying to connect');\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (!this.client) {\n      throw new Error('WalletConnect is not running yet');\n    }\n\n    const sessions: IParsedWalletConnectSession[] = await this.getSessions();\n    for (const session of sessions) {\n      await this.closeSession(session.id);\n    }\n  }\n\n  public async closeSession(sessionId: string, reason?: string): Promise<void> {\n    if (!this.client) {\n      throw new Error('WalletConnect is not running yet');\n    }\n\n    await this.client.disconnect({\n      topic: sessionId,\n      reason: {\n        message: reason || 'Session closed',\n        code: -1,\n      },\n    });\n  }\n\n  public async getSessions(): Promise<IParsedWalletConnectSession[]> {\n    if (!this.client) {\n      throw new Error('WalletConnect is not running yet');\n    }\n\n    return this.client.session.values.map(parseWalletConnectSession);\n  }\n\n  private async getTargetSession(params?: { publicKey?: string }): Promise<IParsedWalletConnectSession> {\n    const activeSessions: IParsedWalletConnectSession[] = await this.getSessions();\n    let targetSession: IParsedWalletConnectSession | undefined = activeSessions.find(\n      (session: IParsedWalletConnectSession): boolean =>\n        session.id === this.activeSession || !!session.accounts.find(a => a.publicKey === params?.publicKey)\n    );\n\n    if (!targetSession) {\n      targetSession = await this.connectWalletConnect();\n    }\n\n    return targetSession;\n  }\n}\n\nexport interface IWalletConnectConstructorParams {\n  projectId: string;\n  name: string;\n  description: string;\n  url: string;\n  icons: string[];\n  method: WalletConnectAllowedMethods;\n  network: WalletNetwork;\n  sessionId?: string;\n  client?: typeof SignClient;\n  modal?: WalletConnectModal;\n  onSessionDeleted?: (sessionId: string) => void;\n}\n\nexport enum WalletConnectTargetChain {\n  PUBLIC = 'stellar:pubnet',\n  TESTNET = 'stellar:testnet',\n}\n\nexport enum WalletConnectAllowedMethods {\n  SIGN = 'stellar_signXDR',\n  SIGN_AND_SUBMIT = 'stellar_signAndSubmitXDR',\n}\n"],"names":["parseWalletConnectSession","session","accounts","namespaces","stellar","map","account","network","split","publicKey","id","topic","name","peer","metadata","description","url","icons","WALLET_CONNECT_ID","WalletConnectTargetChain","WalletConnectAllowedMethods","constructor","wcParams","this","moduleType","ModuleType","BRIDGE_WALLET","productId","productName","productUrl","productIcon","sessionId","setSession","client","modal","qrModal","SignClient","init","projectId","then","console","log","WalletConnectModal","onSessionDeleted","catch","error","isAvailable","getAddress","async","Error","runChecks","address","getTargetSession","e","parseError","signTransaction","xdr","opts","targetSession","signedTxXdr","request","chainId","networkPassphrase","WalletNetwork","PUBLIC","method","params","v","signedXDR","signAuthEntry","code","message","signMessage","getNetwork","activeSession","cb","on","data","connectWalletConnect","uri","approval","connect","requiredNamespaces","methods","chains","events","Promise","resolve","reject","openModal","closeModal","disconnect","sessions","getSessions","closeSession","reason","values","find","a"],"mappings":"+IAOA,MAAMA,EAA6BC,IACjC,MAAMC,EAAWD,EAAQE,WAAWC,QAAQF,SAASG,KAAKC,IAAqB,CAC7EC,QAASD,EAAQE,MAAM,KAAK,GAC5BC,UAAWH,EAAQE,MAAM,KAAK,OAGzB,MAAA,CACLE,GAAIT,EAAQU,MACZC,KAAMX,EAAQY,KAAKC,SAASF,KAC5BG,YAAad,EAAQY,KAAKC,SAASC,YACnCC,IAAKf,EAAQY,KAAKC,SAASE,IAC3BC,MAAOhB,EAAQY,KAAKC,SAASG,MAAM,GACnCf,WACF,EAgBWgB,EAAoB,iBA8PrB,IAAAC,GAAAA,IACVA,EAAS,OAAA,iBACTA,EAAU,QAAA,kBAFAA,IAAAA,GAAA,CAAA,GAKAC,GAAAA,IACVA,EAAO,KAAA,kBACPA,EAAkB,gBAAA,2BAFRA,IAAAA,GAAA,CAAA,iGAjQL,MAkBL,WAAAC,CAAmBC,GAAAC,KAAAD,SAAAA,EAjBnBC,KAAAC,WAAyBC,EAAAA,WAAWC,cAEhBH,KAAAI,UAAAT,EACEK,KAAAK,YAAA,iBACDL,KAAAM,WAAA,6BACCN,KAAAO,YAAA,4DAahBR,EAASS,WACNR,KAAAS,WAAWV,EAASS,WAGvBT,EAASW,QAAUX,EAASY,OAC9BX,KAAKU,OAASX,EAASW,OACvBV,KAAKY,QAAUb,EAASY,OAExBE,EAAAA,WAAWC,KAAK,CACdC,UAAWhB,EAASgB,UACpBxB,SAAU,CACRF,KAAMU,EAASV,KACfI,IAAKM,EAASN,IACdD,YAAaO,EAASP,YACtBE,MAAOK,EAASL,SAGjBsB,MAAeN,IACdO,QAAQC,IAAI,2BACZlB,KAAKU,OAASA,EACdV,KAAKY,QAAU,IAAIO,EAAAA,mBAAmB,CAAEJ,UAAWhB,EAASgB,YAExDhB,EAASqB,kBACNpB,KAAAoB,iBAAiBrB,EAASqB,iBAAgB,IAGlDC,MAAMJ,QAAQK,MACnB,CAhCF,iBAAMC,GACG,OAAA,CAAA,CAkCT,gBAAMC,GAOG,MANWC,WACZ,IAACzB,KAAKU,OACF,MAAA,IAAIgB,MAAM,mCAAkC,EAI/CC,GACJX,MAAKS,UAEG,CAAEG,eADgD5B,KAAK6B,oBAC9BlD,SAAS,GAAGO,cAE7CmC,OAAWS,IACV,MAAMC,EAAAA,WAAWD,EAAC,GACnB,CAGL,qBAAME,CACJC,EACAC,GAcO,MANWT,WACZ,IAACzB,KAAKU,OACF,MAAA,IAAIgB,MAAM,mCAAkC,EAI/CC,GACJX,MAAKS,UACE,MAAAU,QAAmDnC,KAAK6B,iBAAiB,CAAE3C,UAAWgD,GAAMN,UAalG,MAAO,CAAEQ,kBAZiBpC,KAAKU,OAAQ2B,QAAQ,CAC7CjD,MAAO+C,EAAchD,GACrBmD,QACEJ,GAAMK,oBAAsBC,EAAAA,cAAcC,OACtC,iBACA,kBACNJ,QAAS,CACPK,OAAQ1C,KAAKD,SAAS2C,OACtBC,OAAQ,CAAEV,UAEXjB,MAAM4B,GAAWA,EAAEC,YAED,IAEtBxB,OAAWS,IACV,MAAMC,EAAAA,WAAWD,EAAC,GACnB,CAGL,mBAAMgB,GACE,KAAA,CACJC,MAAM,EACNC,QAAS,8DACX,CAGF,iBAAMC,GACE,KAAA,CACJF,MAAM,EACNC,QAAS,4DACX,CAGF,gBAAME,GACE,KAAA,CACJH,MAAM,EACNC,QAAS,2DACX,CAQK,UAAAvC,CAAWD,GAChBR,KAAKmD,cAAgB3C,CAAA,CAGhB,gBAAAY,CAAiBgC,GAClB,IAACpD,KAAKU,OACF,MAAA,IAAIgB,MAAM,oCAGb1B,KAAAU,OAAO2C,GAAG,kBAA0BC,IACvCF,EAAGE,EAAKlE,MAAK,GACd,CAGH,0BAAamE,GACP,IAACvD,KAAKU,OACF,MAAA,IAAIgB,MAAM,oCAGd,IACF,MAAM8B,IAAEA,EAAKC,SAAAA,SAAmBzD,KAAKU,OAAOgD,QAAQ,CAClDC,mBAAoB,CAClB9E,QAAS,CACP+E,QAAS,CAAC5D,KAAKD,SAAS2C,QACxBmB,OAAQ,CACN7D,KAAKD,SAASf,UAAYwD,EAAAA,cAAcC,OACpC,iBACA,mBAENqB,OAAQ,OAIRpF,QAA6C,IAAIqF,SAA6B,CAACC,EAASC,KAExFT,GACFxD,KAAKY,QAAQsD,UAAU,CAAEV,QAIlBC,IACNzC,MAAKtC,IACJsB,KAAKY,QAAQuD,aACbH,EAAQtF,EAAO,IAEhB2C,OAAeC,IACdtB,KAAKY,QAAQuD,aACbF,EAAO3C,EAAK,GACb,IACFN,KAAKvC,GAGD,OADFuB,KAAAS,WAAW/B,EAAQS,IACjBT,QACAoD,GAGD,MAFN9B,KAAKY,QAAQuD,aACblD,QAAQK,MAAMQ,GACR,IAAIJ,MAAM,4CAA2C,CAC7D,CAGF,gBAAM0C,GACA,IAACpE,KAAKU,OACF,MAAA,IAAIgB,MAAM,oCAGZ,MAAA2C,QAAgDrE,KAAKsE,cAC3D,IAAA,MAAW5F,KAAW2F,QACdrE,KAAKuE,aAAa7F,EAAQS,GAClC,CAGF,kBAAaoF,CAAa/D,EAAmBgE,GACvC,IAACxE,KAAKU,OACF,MAAA,IAAIgB,MAAM,0CAGZ1B,KAAKU,OAAO0D,WAAW,CAC3BhF,MAAOoB,EACPgE,OAAQ,CACNxB,QAASwB,GAAU,iBACnBzB,MAAM,IAET,CAGH,iBAAauB,GACP,IAACtE,KAAKU,OACF,MAAA,IAAIgB,MAAM,oCAGlB,OAAO1B,KAAKU,OAAOhC,QAAQ+F,OAAO3F,IAAIL,EAAyB,CAGjE,sBAAcoD,CAAiBc,GAE7B,IAAIR,SADwDnC,KAAKsE,eACWI,MACzEhG,GACCA,EAAQS,KAAOa,KAAKmD,iBAAmBzE,EAAQC,SAAS+F,MAAKC,GAAKA,EAAEzF,YAAcyD,GAAQzD,cAOvF,OAJFiD,IACaA,QAAMnC,KAAKuD,wBAGtBpB,CAAA"}