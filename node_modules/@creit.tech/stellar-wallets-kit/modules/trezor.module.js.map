{"version":3,"file":"trezor.module.js","sources":["../../src/modules/trezor.module.ts"],"sourcesContent":["import TrezorConnect from '@trezor/connect-web';\nimport { transformTransaction } from '@trezor/connect-plugin-stellar';\nimport { Transaction } from '@stellar/stellar-base';\nimport { firstValueFrom } from 'rxjs';\n\nimport {\n  hardwareWalletPaths$,\n  mnemonicPath$,\n  removeHardwareWalletPaths,\n  removeMnemonicPath,\n  selectedNetwork$,\n  setHardwareWalletPaths,\n  setMnemonicPath,\n} from '../state/store';\nimport { ModuleInterface, ModuleType } from '../types';\nimport { parseError } from '../utils';\nimport { StellarSelectorModal } from '../components/selector-modal/stellar-selector-modal';\n\nexport const TREZOR_ID = 'TREZOR';\n\nexport class TrezorModule implements ModuleInterface {\n  TrezorConnect: typeof TrezorConnect =\n    'default' in TrezorConnect ? (TrezorConnect.default as typeof TrezorConnect) : TrezorConnect;\n\n  private _isAvailable: boolean = false;\n\n  moduleType: ModuleType = ModuleType.HW_WALLET;\n\n  productId: string = TREZOR_ID;\n  productName: string = 'Trezor';\n  productUrl: string = 'https://www.trezor.com/';\n  productIcon: string = 'https://stellar.creit.tech/wallet-icons/trezor.png';\n\n  constructor(params: ITrezorModuleParams) {\n    this.TrezorConnect.init({\n      manifest: {\n        appUrl: params.appUrl,\n        email: params.email,\n      },\n      // More advanced options\n      debug: params.debug || false,\n      lazyLoad: params.lazyLoad || false,\n      coreMode: params.coreMode || 'auto',\n    }).then(() => {\n      console.log('Trezor is ready');\n      this._isAvailable = true;\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    removeMnemonicPath();\n    removeHardwareWalletPaths();\n  }\n\n  /**\n   * `TrezorConnect` needs to be started before we can use it but because users most likely\n   * won't use their devices as soon as the site loads, we return `true` since it should be already started\n   * once the user needs to interact with it.\n   */\n  async isAvailable(): Promise<boolean> {\n    return true;\n  }\n\n  async runChecks(): Promise<void> {\n    if (!this._isAvailable) {\n      throw parseError(new Error('Trezor connection has not been started yet.'));\n    }\n  }\n\n  async getAddress(opts?: { path?: string }): Promise<{ address: string }> {\n    try {\n      await this.runChecks();\n\n      const mnemonicPath: string | undefined = opts?.path || (await firstValueFrom(mnemonicPath$));\n\n      if (!mnemonicPath) {\n        const result = await this.openAccountSelector();\n        return { address: result.publicKey };\n      } else {\n        const result = await this.TrezorConnect.stellarGetAddress({ path: mnemonicPath, showOnTrezor: false });\n        if (!result.success) {\n          throw parseError(new Error(result.payload.error));\n        }\n\n        return { address: result.payload.address };\n      }\n    } catch (e) {\n      throw parseError(e);\n    }\n  }\n\n  /**\n   * This method is used by the Wallets Kit itself, if you're a dApp developer, most likely you don't need to use this method.\n   * @param page - {Number}\n   */\n  async getAddresses(page: number = 0): Promise<{ publicKey: string; index: number }[]> {\n    const startIndex: number = page * 10;\n    const bundle: { path: string; showOnTrezor: boolean }[] = new Array(10)\n      .fill(undefined)\n      .map((_, i): { path: string; showOnTrezor: boolean } => ({\n        path: `m/44'/148'/${i + startIndex}'`,\n        showOnTrezor: false,\n      }));\n\n    const result = await this.TrezorConnect.stellarGetAddress({ bundle });\n    if (!result.success) {\n      throw parseError(new Error(result.payload.error));\n    }\n\n    const results = result.payload.map((item, i) => ({\n      publicKey: item.address,\n      index: i + startIndex,\n    }));\n\n    setHardwareWalletPaths(results);\n\n    return results;\n  }\n\n  /**\n   * This method is used by the Wallets Kit itself, if you're a dApp developer, most likely you don't need to use this method.\n   */\n  async openAccountSelector(): Promise<{ publicKey: string; index: number }> {\n    return new Promise((resolve, reject) => {\n      const el = document.createElement('stellar-accounts-selector') as StellarSelectorModal;\n      el.setAttribute('showModal', '');\n      el.setAttribute('loadingAccounts', '');\n      document.body.appendChild(el);\n\n      this.getAddresses()\n        .then(addressesData => {\n          el.setAttribute('accounts', JSON.stringify(addressesData));\n          el.removeAttribute('loadingAccounts');\n        })\n        .catch(err => {\n          el.remove();\n          reject(err);\n        });\n\n      const listener = (event: CustomEvent) => {\n        const { publicKey, index } = event.detail as { publicKey: string; index: number };\n        setMnemonicPath(`44'/148'/${index}'`);\n        resolve({ publicKey, index });\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        el.removeEventListener('account-selected', listener, false);\n        document.body.removeChild(el);\n      };\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      el.addEventListener('account-selected', listener, false);\n\n      const errorListener = (event: CustomEvent) => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        el.removeEventListener('account-selected', listener, false);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        el.removeEventListener('account-selector-closed', errorListener, false);\n        document.body.removeChild(el);\n        reject(event.detail);\n      };\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      el.addEventListener('account-selector-closed', errorListener, false);\n    });\n  }\n\n  async signTransaction(\n    xdr: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n    }\n  ): Promise<{ signedTxXdr: string; signerAddress?: string }> {\n    await this.runChecks();\n\n    let mnemonicPath: string | undefined;\n    let account: string;\n    if (opts?.path) {\n      mnemonicPath = opts.path;\n      const result = await this.TrezorConnect.stellarGetAddress({ path: mnemonicPath, showOnTrezor: false });\n      if (!result.success) {\n        throw new Error(result.payload.error);\n      }\n      account = result.payload.address;\n    } else if (opts?.address) {\n      const paths = await firstValueFrom(hardwareWalletPaths$);\n      const target = paths.find(p => p.publicKey === opts.address);\n      if (!target) throw parseError(new Error('This address has not been loaded from this device'));\n      mnemonicPath = `m/44'/148'/${target.index}'`;\n      account = target.publicKey;\n    } else {\n      mnemonicPath = await firstValueFrom(mnemonicPath$);\n      if (!mnemonicPath)\n        throw parseError(new Error('There is no path available, please call the `getAddress` method first.'));\n      const result = await this.TrezorConnect.stellarGetAddress({ path: mnemonicPath, showOnTrezor: false });\n      if (!result.success) {\n        throw new Error(result.payload.error);\n      }\n      account = result.payload.address;\n    }\n\n    const network: string | undefined = opts?.networkPassphrase || (await firstValueFrom(selectedNetwork$));\n    if (!network) throw parseError(new Error('You need to provide or set a network passphrase'));\n\n    const tx: Transaction = new Transaction(xdr, network);\n    const parsedTx = transformTransaction(mnemonicPath, tx);\n    const result = await this.TrezorConnect.stellarSignTransaction(parsedTx);\n\n    if (!result.success) {\n      throw parseError(new Error(result.payload.error));\n    }\n\n    tx.addSignature(account, Buffer.from(result.payload.signature, 'hex').toString('base64'));\n\n    return {\n      signedTxXdr: tx.toXDR(),\n      signerAddress: account,\n    };\n  }\n\n  async signAuthEntry(): Promise<{ signedAuthEntry: string; signerAddress?: string }> {\n    throw {\n      code: -3,\n      message: 'Trezor Wallets do not support the \"signAuthEntry\" method',\n    };\n  }\n\n  async signMessage(): Promise<{ signedMessage: string; signerAddress?: string }> {\n    throw {\n      code: -3,\n      message: 'Trezor Wallets do not support the \"signMessage\" method',\n    };\n  }\n\n  async getNetwork(): Promise<{ network: string; networkPassphrase: string }> {\n    throw {\n      code: -3,\n      message: 'Trezor Wallets do not support the \"getNetwork\" method',\n    };\n  }\n}\n\n/**\n * These values are used to start the TrezorConnect library\n */\nexport interface ITrezorModuleParams {\n  appUrl: string;\n  email: string;\n  debug?: boolean;\n  lazyLoad?: boolean;\n  coreMode?: 'auto' | 'iframe' | 'popup';\n}\n"],"names":["TREZOR_ID","TrezorModule","constructor","params","this","TrezorConnect","default","_isAvailable","moduleType","ModuleType","HW_WALLET","productId","productName","productUrl","productIcon","init","manifest","appUrl","email","debug","lazyLoad","coreMode","then","console","log","disconnect","removeMnemonicPath","removeHardwareWalletPaths","isAvailable","runChecks","parseError","Error","getAddress","opts","mnemonicPath","path","firstValueFrom","mnemonicPath$","result","stellarGetAddress","showOnTrezor","success","payload","error","address","openAccountSelector","publicKey","e","getAddresses","page","startIndex","bundle","Array","fill","map","_","i","results","item","index","setHardwareWalletPaths","Promise","resolve","reject","el","document","createElement","setAttribute","body","appendChild","addressesData","JSON","stringify","removeAttribute","catch","err","remove","listener","event","detail","setMnemonicPath","removeEventListener","removeChild","addEventListener","errorListener","signTransaction","xdr","account","target","hardwareWalletPaths$","find","p","network","networkPassphrase","selectedNetwork$","tx","Transaction","parsedTx","transformTransaction","stellarSignTransaction","addSignature","Buffer","from","signature","toString","signedTxXdr","toXDR","signerAddress","signAuthEntry","code","message","signMessage","getNetwork"],"mappings":"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"}