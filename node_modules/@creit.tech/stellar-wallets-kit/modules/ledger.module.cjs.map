{"version":3,"file":"ledger.module.cjs","sources":["../../src/modules/ledger.module.ts"],"sourcesContent":["import Str from '@ledgerhq/hw-app-str';\nimport Transport from '@ledgerhq/hw-transport';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport { Buffer } from 'buffer';\nimport { firstValueFrom } from 'rxjs';\nimport { StellarSelectorModal } from '../components/selector-modal/stellar-selector-modal';\nimport {\n  hardwareWalletPaths$,\n  mnemonicPath$,\n  removeHardwareWalletPaths,\n  removeMnemonicPath,\n  selectedNetwork$,\n  setHardwareWalletPaths,\n  setMnemonicPath,\n} from '../state/store';\nimport { ModuleInterface, ModuleType } from '../types';\nimport { StrKey } from '@stellar/stellar-base';\nimport { parseError } from '../utils';\nimport { Transaction } from '@stellar/stellar-base';\n\nexport const LEDGER_ID = 'LEDGER';\n\nexport class LedgerModule implements ModuleInterface {\n  moduleType: ModuleType = ModuleType.HW_WALLET;\n\n  productId: string = LEDGER_ID;\n  productName: string = 'Ledger';\n  productUrl: string = 'https://www.ledger.com/';\n  productIcon: string = 'https://stellar.creit.tech/wallet-icons/ledger.png';\n\n  private _transport?: Transport;\n  async transport() {\n    if (!(await TransportWebUSB.isSupported())) throw new Error('Ledger can not be used with this device.');\n\n    if (!this._transport) {\n      this._transport = await TransportWebUSB.create();\n    }\n\n    return this._transport;\n  }\n\n  async disconnect(): Promise<void> {\n    removeMnemonicPath();\n    removeHardwareWalletPaths();\n    this._transport?.close();\n    this._transport = undefined;\n  }\n\n  /**\n   * This always return true because in theory ledgers aren't supposed\n   * to be connected at all time\n   */\n  async isAvailable(): Promise<boolean> {\n    return TransportWebUSB.isSupported();\n  }\n\n  async runChecks(): Promise<void> {\n    if (!(await this.isAvailable())) {\n      throw new Error('Ledger wallets can not be used');\n    }\n  }\n\n  async getAddress(params?: { path?: string }): Promise<{ address: string }> {\n    await this.runChecks();\n\n    let mnemonicPath: string | undefined = await firstValueFrom(mnemonicPath$);\n    const finalTransport: Transport = await this.transport();\n    const str = new Str(finalTransport);\n\n    if (!mnemonicPath) {\n      await this.openAccountSelector();\n      mnemonicPath = await firstValueFrom(mnemonicPath$);\n    }\n\n    try {\n      const result: { rawPublicKey: Buffer } = await str.getPublicKey(params?.path || mnemonicPath!);\n      return { address: StrKey.encodeEd25519PublicKey(result.rawPublicKey) };\n    } catch (e) {\n      throw parseError(e);\n    }\n  }\n\n  /**\n   * This method is used by the Wallets Kit itself, if you're a dApp developer, most likely you don't need to use this method.\n   * @param page - {Number}\n   */\n  async getAddresses(page: number = 0): Promise<{ publicKey: string; index: number }[]> {\n    const finalTransport: Transport = await this.transport();\n    const str = new Str(finalTransport);\n    const startIndex: number = page * 10;\n    const results: { publicKey: string; index: number }[] = [];\n\n    for (let i = 0; i < 10; i++) {\n      const result: { rawPublicKey: Buffer } = await str.getPublicKey(`44'/148'/${i + startIndex}'`);\n      results.push({\n        publicKey: StrKey.encodeEd25519PublicKey(result.rawPublicKey),\n        index: i + startIndex,\n      });\n    }\n\n    setHardwareWalletPaths(results);\n\n    return results;\n  }\n\n  /**\n   * This method is used by the Wallets Kit itself, if you're a dApp developer, most likely you don't need to use this method.\n   */\n  async openAccountSelector(): Promise<{ publicKey: string; index: number }> {\n    return new Promise((resolve, reject) => {\n      const el = document.createElement('stellar-accounts-selector') as StellarSelectorModal;\n      el.setAttribute('showModal', '');\n      el.setAttribute('loadingAccounts', '');\n      document.body.appendChild(el);\n\n      this.getAddresses()\n        .then(addressesData => {\n          el.setAttribute('accounts', JSON.stringify(addressesData));\n          el.removeAttribute('loadingAccounts');\n        })\n        .catch(err => {\n          el.remove();\n          reject(err);\n        });\n\n      const listener = (event: CustomEvent) => {\n        const { publicKey, index } = event.detail as { publicKey: string; index: number };\n        setMnemonicPath(`44'/148'/${index}'`);\n        resolve({ publicKey, index });\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        el.removeEventListener('account-selected', listener, false);\n        document.body.removeChild(el);\n      };\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      el.addEventListener('account-selected', listener, false);\n\n      const errorListener = (event: CustomEvent) => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        el.removeEventListener('account-selected', listener, false);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        el.removeEventListener('account-selector-closed', errorListener, false);\n        document.body.removeChild(el);\n        reject(event.detail);\n      };\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      el.addEventListener('account-selector-closed', errorListener, false);\n    });\n  }\n\n  async signTransaction(\n    xdr: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n      nonBlindTx?: boolean;\n    }\n  ): Promise<{ signedTxXdr: string; signerAddress?: string }> {\n    await this.runChecks();\n    const finalTransport: Transport = await this.transport();\n    const str = new Str(finalTransport);\n\n    let mnemonicPath: string | undefined;\n    let account: string;\n    if (opts?.path) {\n      mnemonicPath = opts.path;\n      const result: { rawPublicKey: Buffer } = await str.getPublicKey(mnemonicPath);\n      account = StrKey.encodeEd25519PublicKey(result.rawPublicKey);\n    } else if (opts?.address) {\n      const paths = await firstValueFrom(hardwareWalletPaths$);\n      const target = paths.find(p => p.publicKey === opts.address);\n      if (!target) throw new Error('This address has not been loaded from this ledger');\n      mnemonicPath = `44'/148'/${target.index}'`;\n      account = target.publicKey;\n    } else {\n      mnemonicPath = await firstValueFrom(mnemonicPath$);\n      if (!mnemonicPath) throw new Error('There is no path available, please call the `getAddress` method first.');\n      const result: { rawPublicKey: Buffer } = await str.getPublicKey(mnemonicPath);\n      account = StrKey.encodeEd25519PublicKey(result.rawPublicKey);\n    }\n\n    const network: string | undefined = opts?.networkPassphrase || (await firstValueFrom(selectedNetwork$));\n    if (!network) throw new Error('You need to provide or set a network passphrase');\n\n    const tx: Transaction = new Transaction(xdr, network);\n\n    const result: { signature: Buffer } = opts?.nonBlindTx\n      ? await str.signTransaction(mnemonicPath, tx.signatureBase())\n      : await str.signHash(mnemonicPath, tx.hash());\n\n    tx.addSignature(account, result.signature.toString('base64'));\n\n    return {\n      signedTxXdr: tx.toXDR(),\n      signerAddress: account,\n    };\n  }\n\n  async signAuthEntry(): Promise<{ signedAuthEntry: string; signerAddress?: string }> {\n    throw {\n      code: -3,\n      message: 'Ledger Wallets do not support the \"signAuthEntry\" function',\n    };\n  }\n\n  async signMessage(): Promise<{ signedMessage: string; signerAddress?: string }> {\n    throw {\n      code: -3,\n      message: 'Ledger Wallets do not support the \"signMessage\" function',\n    };\n  }\n\n  async getNetwork(): Promise<{ network: string; networkPassphrase: string }> {\n    throw {\n      code: -3,\n      message: 'Ledger Wallets do not support the \"getNetwork\" function',\n    };\n  }\n}\n"],"names":["LEDGER_ID","constructor","this","moduleType","ModuleType","HW_WALLET","productId","productName","productUrl","productIcon","transport","TransportWebUSB","isSupported","Error","_transport","create","disconnect","removeMnemonicPath","removeHardwareWalletPaths","close","isAvailable","runChecks","getAddress","params","mnemonicPath","firstValueFrom","mnemonicPath$","finalTransport","str","Str","openAccountSelector","result","getPublicKey","path","address","StrKey","encodeEd25519PublicKey","rawPublicKey","e","parseError","getAddresses","page","startIndex","results","i","push","publicKey","index","setHardwareWalletPaths","Promise","resolve","reject","el","document","createElement","setAttribute","body","appendChild","then","addressesData","JSON","stringify","removeAttribute","catch","err","remove","listener","event","detail","setMnemonicPath","removeEventListener","removeChild","addEventListener","errorListener","signTransaction","xdr","opts","account","target","hardwareWalletPaths$","find","p","network","networkPassphrase","selectedNetwork$","tx","Transaction","nonBlindTx","signatureBase","signHash","hash","addSignature","signature","toString","signedTxXdr","toXDR","signerAddress","signAuthEntry","code","message","signMessage","getNetwork"],"mappings":"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"}