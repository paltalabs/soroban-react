{"version":3,"file":"freighter.module.cjs","sources":["../../src/modules/freighter.module.ts"],"sourcesContent":["import {\n  isConnected,\n  signTransaction,\n  signAuthEntry,\n  requestAccess,\n  signMessage,\n  getNetwork,\n  getAddress,\n} from '@stellar/freighter-api';\nimport { ModuleInterface, ModuleType } from '../types';\nimport { parseError } from '../utils';\nimport { Buffer } from 'buffer';\n\nexport const FREIGHTER_ID = 'freighter';\n\nexport class FreighterModule implements ModuleInterface {\n  moduleType: ModuleType = ModuleType.HOT_WALLET;\n\n  productId: string = FREIGHTER_ID;\n  productName: string = 'Freighter';\n  productUrl: string = 'https://freighter.app';\n  productIcon: string = 'https://stellar.creit.tech/wallet-icons/freighter.png';\n\n  async runChecks(): Promise<void> {\n    if (!(await this.isAvailable())) {\n      throw new Error('Freighter is not connected');\n    }\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return isConnected()\n      .then(({ isConnected, error }) => !error && isConnected)\n      .catch((): boolean => false);\n  }\n\n  async getAddress(): Promise<{ address: string }> {\n    return this.runChecks()\n      .then(() => requestAccess())\n      .then(() => getAddress())\n      .then(({ address, error }) => {\n        if (error) throw error;\n\n        return { address };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signTransaction(\n    xdr: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n      submit?: boolean;\n      submitUrl?: string;\n    }\n  ): Promise<{ signedTxXdr: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedTxXdr, signerAddress, error } = await signTransaction(xdr, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error) throw error;\n\n        return { signedTxXdr, signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signAuthEntry(\n    authEntry: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n    }\n  ): Promise<{ signedAuthEntry: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedAuthEntry, signerAddress, error } = await signAuthEntry(authEntry, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error || !signedAuthEntry) throw error;\n\n        return { signedAuthEntry: Buffer.from(signedAuthEntry).toString('base64'), signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async signMessage(\n    message: string,\n    opts?: {\n      networkPassphrase?: string;\n      address?: string;\n      path?: string;\n    }\n  ): Promise<{ signedMessage: string; signerAddress?: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { signedMessage, signerAddress, error } = await signMessage(message, {\n          address: opts?.address,\n          networkPassphrase: opts?.networkPassphrase,\n        });\n\n        if (error || !signedMessage) throw error;\n\n        return { signedMessage: Buffer.from(signedMessage).toString('base64'), signerAddress: signerAddress };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n\n  async getNetwork(): Promise<{ network: string; networkPassphrase: string }> {\n    return this.runChecks()\n      .then(async () => {\n        const { network, networkPassphrase, error } = await getNetwork();\n\n        if (error) throw error;\n\n        return { network, networkPassphrase };\n      })\n      .catch(e => {\n        throw parseError(e);\n      });\n  }\n}\n"],"names":["FREIGHTER_ID","constructor","this","moduleType","ModuleType","HOT_WALLET","productId","productName","productUrl","productIcon","runChecks","isAvailable","Error","isConnected","then","error","catch","getAddress","requestAccess","address","e","parseError","signTransaction","xdr","opts","async","signedTxXdr","signerAddress","networkPassphrase","signAuthEntry","authEntry","signedAuthEntry","Buffer","from","toString","signMessage","message","signedMessage","getNetwork","network"],"mappings":"6HAaO,MAAMA,EAAe,2DAErB,MAAA,WAAAC,GACLC,KAAAC,WAAyBC,EAAAA,WAAWC,WAEhBH,KAAAI,UAAAN,EACEE,KAAAK,YAAA,YACDL,KAAAM,WAAA,wBACCN,KAAAO,YAAA,uDAAA,CAEtB,eAAMC,GACJ,UAAYR,KAAKS,cACT,MAAA,IAAIC,MAAM,6BAClB,CAGF,iBAAMD,GACJ,OAAOE,EAAYA,cAChBC,MAAK,EAAGD,YAAAA,EAAaE,YAAaA,GAASF,IAC3CG,OAAM,KAAe,GAAK,CAG/B,gBAAMC,GACJ,OAAOf,KAAKQ,YACTI,MAAK,IAAMI,EAAAA,kBACXJ,MAAK,IAAMG,EAAAA,eACXH,MAAK,EAAGK,UAASJ,YAChB,GAAIA,EAAa,MAAAA,EAEjB,MAAO,CAAEI,UAAQ,IAElBH,OAAWI,IACV,MAAMC,EAAAA,WAAWD,EAAC,GACnB,CAGL,qBAAME,CACJC,EACAC,GAQA,OAAOtB,KAAKQ,YACTI,MAAKW,UACJ,MAAMC,YAAEA,EAAaC,cAAAA,EAAAZ,MAAeA,SAAgBO,kBAAgBC,EAAK,CACvEJ,QAASK,GAAML,QACfS,kBAAmBJ,GAAMI,oBAG3B,GAAIb,EAAa,MAAAA,EAEV,MAAA,CAAEW,cAAaC,gBAA6B,IAEpDX,OAAWI,IACV,MAAMC,EAAAA,WAAWD,EAAC,GACnB,CAGL,mBAAMS,CACJC,EACAN,GAMA,OAAOtB,KAAKQ,YACTI,MAAKW,UACJ,MAAMM,gBAAEA,EAAiBJ,cAAAA,EAAAZ,MAAeA,SAAgBc,gBAAcC,EAAW,CAC/EX,QAASK,GAAML,QACfS,kBAAmBJ,GAAMI,oBAGvB,GAAAb,IAAUgB,EAAuB,MAAAhB,EAE9B,MAAA,CAAEgB,gBAAiBC,EAAAA,OAAOC,KAAKF,GAAiBG,SAAS,UAAWP,gBAA6B,IAEzGX,OAAWI,IACV,MAAMC,EAAAA,WAAWD,EAAC,GACnB,CAGL,iBAAMe,CACJC,EACAZ,GAMA,OAAOtB,KAAKQ,YACTI,MAAKW,UACJ,MAAMY,cAAEA,EAAeV,cAAAA,EAAAZ,MAAeA,SAAgBoB,cAAYC,EAAS,CACzEjB,QAASK,GAAML,QACfS,kBAAmBJ,GAAMI,oBAGvB,GAAAb,IAAUsB,EAAqB,MAAAtB,EAE5B,MAAA,CAAEsB,cAAeL,EAAAA,OAAOC,KAAKI,GAAeH,SAAS,UAAWP,gBAA6B,IAErGX,OAAWI,IACV,MAAMC,EAAAA,WAAWD,EAAC,GACnB,CAGL,gBAAMkB,GACJ,OAAOpC,KAAKQ,YACTI,MAAKW,UACJ,MAAMc,QAAEA,EAASX,kBAAAA,EAAAb,MAAmBA,SAAgBuB,EAAAA,aAEpD,GAAIvB,EAAa,MAAAA,EAEV,MAAA,CAAEwB,UAASX,oBAAkB,IAErCZ,OAAWI,IACV,MAAMC,EAAAA,WAAWD,EAAC,GACnB"}