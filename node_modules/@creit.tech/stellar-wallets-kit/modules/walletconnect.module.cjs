"use strict";var e=require("@walletconnect/modal"),t=require("@walletconnect/sign-client"),n=require("../types.cjs"),s=require("../utils.cjs");const o=e=>{const t=e.namespaces.stellar.accounts.map((e=>({network:e.split(":")[1],publicKey:e.split(":")[2]})));return{id:e.topic,name:e.peer.metadata.name,description:e.peer.metadata.description,url:e.peer.metadata.url,icons:e.peer.metadata.icons[0],accounts:t}},i="wallet_connect";var r=(e=>(e.PUBLIC="stellar:pubnet",e.TESTNET="stellar:testnet",e))(r||{}),a=(e=>(e.SIGN="stellar_signXDR",e.SIGN_AND_SUBMIT="stellar_signAndSubmitXDR",e))(a||{});exports.WALLET_CONNECT_ID=i,exports.WalletConnectAllowedMethods=a,exports.WalletConnectModule=class{constructor(s){this.wcParams=s,this.moduleType=n.ModuleType.BRIDGE_WALLET,this.productId=i,this.productName="Wallet Connect",this.productUrl="https://walletconnect.com/",this.productIcon="https://stellar.creit.tech/wallet-icons/walletconnect.png",s.sessionId&&this.setSession(s.sessionId),s.client&&s.modal?(this.client=s.client,this.qrModal=s.modal):t.SignClient.init({projectId:s.projectId,metadata:{name:s.name,url:s.url,description:s.description,icons:s.icons}}).then((t=>{console.log("WalletConnect is ready."),this.client=t,this.qrModal=new e.WalletConnectModal({projectId:s.projectId}),s.onSessionDeleted&&this.onSessionDeleted(s.onSessionDeleted)})).catch(console.error)}async isAvailable(){return!0}async getAddress(){return(async()=>{if(!this.client)throw new Error("WalletConnect is not running yet")})().then((async()=>({address:(await this.getTargetSession()).accounts[0].publicKey}))).catch((e=>{throw s.parseError(e)}))}async signTransaction(e,t){return(async()=>{if(!this.client)throw new Error("WalletConnect is not running yet")})().then((async()=>{const s=await this.getTargetSession({publicKey:t?.address});return{signedTxXdr:await this.client.request({topic:s.id,chainId:t?.networkPassphrase===n.WalletNetwork.PUBLIC?"stellar:pubnet":"stellar:testnet",request:{method:this.wcParams.method,params:{xdr:e}}}).then((e=>e.signedXDR))}})).catch((e=>{throw s.parseError(e)}))}async signAuthEntry(){throw{code:-3,message:'WalletConnect does not support the "signAuthEntry" function'}}async signMessage(){throw{code:-3,message:'WalletConnect does not support the "signMessage" function'}}async getNetwork(){throw{code:-3,message:'WalletConnect does not support the "getNetwork" function'}}setSession(e){this.activeSession=e}onSessionDeleted(e){if(!this.client)throw new Error("WalletConnect is not running yet");this.client.on("session_delete",(t=>{e(t.topic)}))}async connectWalletConnect(){if(!this.client)throw new Error("WalletConnect is not running yet");try{const{uri:e,approval:t}=await this.client.connect({requiredNamespaces:{stellar:{methods:[this.wcParams.method],chains:[this.wcParams.network===n.WalletNetwork.PUBLIC?"stellar:pubnet":"stellar:testnet"],events:[]}}}),s=await new Promise(((n,s)=>{e&&this.qrModal.openModal({uri:e}),t().then((e=>{this.qrModal.closeModal(),n(e)})).catch((e=>{this.qrModal.closeModal(),s(e)}))})).then(o);return this.setSession(s.id),s}catch(e){throw this.qrModal.closeModal(),console.error(e),new Error("There was an error when trying to connect")}}async disconnect(){if(!this.client)throw new Error("WalletConnect is not running yet");const e=await this.getSessions();for(const t of e)await this.closeSession(t.id)}async closeSession(e,t){if(!this.client)throw new Error("WalletConnect is not running yet");await this.client.disconnect({topic:e,reason:{message:t||"Session closed",code:-1}})}async getSessions(){if(!this.client)throw new Error("WalletConnect is not running yet");return this.client.session.values.map(o)}async getTargetSession(e){let t=(await this.getSessions()).find((t=>t.id===this.activeSession||!!t.accounts.find((t=>t.publicKey===e?.publicKey))));return t||(t=await this.connectWalletConnect()),t}},exports.WalletConnectTargetChain=r;
//# sourceMappingURL=walletconnect.module.cjs.map
