{"version":3,"sources":["../src/airdrop-internal.ts","../src/airdrop.ts","../src/compute-limit-internal.ts","../src/compute-limit.ts","../src/decompile-transaction-message-fetching-lookup-tables.ts","../src/send-transaction-internal.ts","../src/send-and-confirm-durable-nonce-transaction.ts","../src/send-and-confirm-transaction.ts","../src/send-transaction-without-confirming.ts"],"names":["getBase64EncodedWireTransaction","createRecentSignatureConfirmationPromiseFactory"],"mappings":"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","file":"index.node.mjs","sourcesContent":["import type { Address } from '@solana/addresses';\nimport type { Signature } from '@solana/keys';\nimport type { RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { Commitment, Lamports } from '@solana/rpc-types';\nimport { waitForRecentTransactionConfirmationUntilTimeout } from '@solana/transaction-confirmation';\n\ntype RequestAndConfirmAirdropConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    confirmSignatureOnlyTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) => Promise<void>;\n    lamports: Lamports;\n    recipientAddress: Address;\n    rpc: Rpc<RequestAirdropApi>;\n}>;\n\nexport async function requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmSignatureOnlyTransaction,\n    lamports,\n    recipientAddress,\n    rpc,\n}: RequestAndConfirmAirdropConfig): Promise<Signature> {\n    const airdropTransactionSignature = await rpc\n        .requestAirdrop(recipientAddress, lamports, { commitment })\n        .send({ abortSignal });\n    await confirmSignatureOnlyTransaction({\n        abortSignal,\n        commitment,\n        signature: airdropTransactionSignature,\n    });\n    return airdropTransactionSignature;\n}\n","import type { Signature } from '@solana/keys';\nimport type { GetSignatureStatusesApi, RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createRecentSignatureConfirmationPromiseFactory,\n    getTimeoutPromise,\n    waitForRecentTransactionConfirmationUntilTimeout,\n} from '@solana/transaction-confirmation';\n\nimport { requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT } from './airdrop-internal';\n\ntype AirdropFunction = (\n    config: Omit<\n        Parameters<typeof requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmSignatureOnlyTransaction' | 'rpc'\n    >,\n) => Promise<Signature>;\n\ntype AirdropFactoryConfig<TCluster> = {\n    rpc: Rpc<GetSignatureStatusesApi & RequestAirdropApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'devnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'mainnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'testnet'>): AirdropFunction;\nexport function airdropFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: AirdropFactoryConfig<TCluster>): AirdropFunction {\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmSignatureOnlyTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmationUntilTimeout({\n            ...config,\n            getRecentSignatureConfirmationPromise,\n            getTimeoutPromise,\n        });\n    }\n    return async function airdrop(config) {\n        return await requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmSignatureOnlyTransaction,\n            rpc,\n        });\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { getU32Encoder } from '@solana/codecs';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    IInstruction,\n    IInstructionWithData,\n    isInstructionForProgram,\n    isInstructionWithData,\n} from '@solana/instructions';\nimport { Rpc, SimulateTransactionApi } from '@solana/rpc';\nimport { Blockhash, Commitment, Slot } from '@solana/rpc-types';\nimport {\n    appendTransactionMessageInstruction,\n    CompilableTransactionMessage,\n    isDurableNonceTransaction,\n    isTransactionMessageWithBlockhashLifetime,\n    ITransactionMessageWithFeePayer,\n    setTransactionMessageLifetimeUsingBlockhash,\n    TransactionMessage,\n} from '@solana/transaction-messages';\nimport { compileTransaction, getBase64EncodedWireTransaction } from '@solana/transactions';\n\ntype ComputeUnitEstimateForTransactionMessageConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n    rpc: Rpc<SimulateTransactionApi>;\n    transactionMessage: CompilableTransactionMessage | (ITransactionMessageWithFeePayer & TransactionMessage);\n}>;\n\nconst COMPUTE_BUDGET_PROGRAM_ADDRESS =\n    'ComputeBudget111111111111111111111111111111' as Address<'ComputeBudget111111111111111111111111111111'>;\n// HACK: Since the `compileTransaction()` method will not compile a transaction with no lifetime we\n// supply a dummy lifetime.\nconst INVALID_BUT_SUFFICIENT_FOR_COMPILATION_BLOCKHASH = {\n    blockhash: '11111111111111111111111111111111' as Blockhash,\n    lastValidBlockHeight: 0n, // This is not included in compiled transactions; it can be anything.\n} as const;\nconst SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX = 0x02;\n\nfunction createComputeUnitLimitInstruction(units: number): IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> {\n    const data = new Uint8Array(5);\n    data[0] = SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX;\n    getU32Encoder().write(units, data, 1 /* offset */);\n    return Object.freeze({\n        data,\n        programAddress: COMPUTE_BUDGET_PROGRAM_ADDRESS,\n    });\n}\n\nfunction isSetComputeLimitInstruction(\n    instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n    return (\n        isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n        isInstructionWithData(instruction) &&\n        instruction.data[0] === SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX\n    );\n}\n\n/**\n * Simulates a transaction message on the network and returns the number of compute units it\n * consumed during simulation.\n *\n * The estimate this function returns can be used to set a compute unit limit on the transaction.\n * Correctly budgeting a compute unit limit for your transaction message can increase the probability\n * that your transaction will be accepted for processing.\n *\n * If you don't declare a compute unit limit on your transaction, validators will assume an upper\n * limit of 200K compute units (CU) per instruction. Since validators have an incentive to pack as\n * many transactions into each block as possible, they may choose to include transactions that they\n * know will fit into the remaining compute budget for the current block over transactions that\n * might not. For this reason, you should set a compute unit limit on each of your transaction\n * messages, whenever possible.\n *\n * ## Example\n *\n * ```ts\n * import { getSetComputeLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/web3.js';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage =\n *     getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume.\n * const computeUnitsEstimate =\n *     await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n *\n * > [!WARNING]\n * > The compute unit estimate is just that &ndash; an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n */\nexport async function getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    rpc,\n    transactionMessage,\n    ...simulateConfig\n}: ComputeUnitEstimateForTransactionMessageConfig): Promise<number> {\n    /**\n     * STEP 1: Make sure the transaction message will not fail in simulation for lack of a lifetime\n     *         - either a recent blockhash lifetime or a nonce.\n     */\n    const isDurableNonceTransactionMessage = isDurableNonceTransaction(transactionMessage);\n    let compilableTransactionMessage;\n    if (isDurableNonceTransactionMessage || isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        compilableTransactionMessage = transactionMessage;\n    } else {\n        compilableTransactionMessage = setTransactionMessageLifetimeUsingBlockhash(\n            INVALID_BUT_SUFFICIENT_FOR_COMPILATION_BLOCKHASH,\n            transactionMessage,\n        );\n    }\n    /**\n     * STEP 2: Ensure that the message has a `SetComputeLimit` instruction. The set compute limit\n     *         instruction itself consumes compute units, so it must be included in the simulation.\n     */\n    const existingSetComputeUnitLimitInstructionIndex =\n        transactionMessage.instructions.findIndex(isSetComputeLimitInstruction);\n    const maxComputeUnitLimitInstruction = createComputeUnitLimitInstruction(1_400_000 /* MAX_COMPUTE_UNIT_LIMIT */);\n    if (existingSetComputeUnitLimitInstructionIndex === -1) {\n        compilableTransactionMessage = appendTransactionMessageInstruction(\n            maxComputeUnitLimitInstruction,\n            compilableTransactionMessage,\n        );\n    } else {\n        const nextInstructions = [...compilableTransactionMessage.instructions];\n        nextInstructions.splice(existingSetComputeUnitLimitInstructionIndex, 1, maxComputeUnitLimitInstruction);\n        compilableTransactionMessage = Object.freeze({\n            ...compilableTransactionMessage,\n            instructions: nextInstructions,\n        } as typeof compilableTransactionMessage);\n    }\n    /**\n     * STEP 3: Simulate the transaction to measure its compute unit consumption.\n     */\n    const compiledTransaction = compileTransaction(compilableTransactionMessage);\n    const wireTransactionBytes = getBase64EncodedWireTransaction(compiledTransaction);\n    try {\n        const {\n            value: { err: transactionError, unitsConsumed },\n        } = await rpc\n            .simulateTransaction(wireTransactionBytes, {\n                ...simulateConfig,\n                encoding: 'base64',\n                replaceRecentBlockhash: !isDurableNonceTransactionMessage,\n                sigVerify: false,\n            })\n            .send({ abortSignal });\n        if (unitsConsumed == null) {\n            // This should never be hit, because all RPCs should support `unitsConsumed` by now.\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT);\n        }\n        // FIXME(https://github.com/anza-xyz/agave/issues/1295): The simulation response returns\n        // compute units as a u64, but the `SetComputeLimit` instruction only accepts a u32. Until\n        // this changes, downcast it.\n        const downcastUnitsConsumed = unitsConsumed > 4_294_967_295n ? 4_294_967_295 : Number(unitsConsumed);\n        if (transactionError) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT, {\n                cause: transactionError,\n                unitsConsumed: downcastUnitsConsumed,\n            });\n        }\n        return downcastUnitsConsumed;\n    } catch (e) {\n        if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT)) throw e;\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT, {\n            cause: e,\n        });\n    }\n}\n","import { Rpc, SimulateTransactionApi } from '@solana/rpc';\nimport {\n    CompilableTransactionMessage,\n    ITransactionMessageWithFeePayer,\n    TransactionMessage,\n} from '@solana/transaction-messages';\n\nimport { getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT } from './compute-limit-internal';\n\ntype ComputeUnitEstimateForTransactionMessageFactoryConfig = Readonly<{\n    rpc: Rpc<SimulateTransactionApi>;\n}>;\ntype ComputeUnitEstimateForTransactionMessageFunction = (\n    transactionMessage: CompilableTransactionMessage | (ITransactionMessageWithFeePayer & TransactionMessage),\n    config?: Omit<\n        Parameters<typeof getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'rpc' | 'transactionMessage'\n    >,\n) => Promise<number>;\n\nexport function getComputeUnitEstimateForTransactionMessageFactory({\n    rpc,\n}: ComputeUnitEstimateForTransactionMessageFactoryConfig): ComputeUnitEstimateForTransactionMessageFunction {\n    return async function getComputeUnitEstimateForTransactionMessage(transactionMessage, config) {\n        return await getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transactionMessage,\n        });\n    };\n}\n","import {\n    assertAccountsDecoded,\n    assertAccountsExist,\n    type FetchAccountsConfig,\n    fetchJsonParsedAccounts,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport {\n    type AddressesByLookupTableAddress,\n    CompilableTransactionMessage,\n    CompiledTransactionMessage,\n    decompileTransactionMessage,\n} from '@solana/transaction-messages';\n\ntype FetchedAddressLookup = {\n    addresses: Address[];\n};\n\nasync function fetchLookupTables(\n    lookupTableAddresses: Address[],\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: FetchAccountsConfig,\n): Promise<AddressesByLookupTableAddress> {\n    const fetchedLookupTables = await fetchJsonParsedAccounts<FetchedAddressLookup[]>(\n        rpc,\n        lookupTableAddresses,\n        config,\n    );\n    assertAccountsDecoded(fetchedLookupTables);\n    assertAccountsExist(fetchedLookupTables);\n\n    return fetchedLookupTables.reduce<AddressesByLookupTableAddress>((acc, lookup) => {\n        return {\n            ...acc,\n            [lookup.address]: lookup.data.addresses,\n        };\n    }, {});\n}\n\ntype DecompileTransactionMessageFetchingLookupTablesConfig = FetchAccountsConfig & {\n    lastValidBlockHeight?: bigint;\n};\n\nexport async function decompileTransactionMessageFetchingLookupTables(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: DecompileTransactionMessageFetchingLookupTablesConfig,\n): Promise<CompilableTransactionMessage> {\n    const lookupTables =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? compiledTransactionMessage.addressTableLookups\n            : [];\n    const lookupTableAddresses = lookupTables.map(l => l.lookupTableAddress);\n\n    const { lastValidBlockHeight, ...fetchAccountsConfig } = config ?? {};\n    const addressesByLookupTableAddress =\n        lookupTableAddresses.length > 0 ? await fetchLookupTables(lookupTableAddresses, rpc, fetchAccountsConfig) : {};\n\n    return decompileTransactionMessage(compiledTransactionMessage, {\n        addressesByLookupTableAddress,\n        lastValidBlockHeight,\n    });\n}\n","import type { Signature } from '@solana/keys';\nimport type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { Commitment, commitmentComparator } from '@solana/rpc-types';\nimport {\n    waitForDurableNonceTransactionConfirmation,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport {\n    FullySignedTransaction,\n    getBase64EncodedWireTransaction,\n    TransactionWithBlockhashLifetime,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions';\n\ninterface SendAndConfirmDurableNonceTransactionConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmDurableNonceTransaction: (\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: FullySignedTransaction & TransactionWithDurableNonceLifetime;\n}\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmRecentTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: FullySignedTransaction & TransactionWithBlockhashLifetime;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    rpc: Rpc<SendTransactionApi>;\n    transaction: FullySignedTransaction;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n    NonNullable<Parameters<SendTransactionApi['sendTransaction']>[1]>,\n    'encoding'\n>;\n\nfunction getSendTransactionConfigWithAdjustedPreflightCommitment(\n    commitment: Commitment,\n    config?: SendTransactionConfigWithoutEncoding,\n): SendTransactionConfigWithoutEncoding | void {\n    if (\n        // The developer has supplied no value for `preflightCommitment`.\n        !config?.preflightCommitment &&\n        // The value of `commitment` is lower than the server default of `preflightCommitment`.\n        commitmentComparator(commitment, 'finalized' /* default value of `preflightCommitment` */) < 0\n    ) {\n        return {\n            ...config,\n            // In the common case, it is unlikely that you want to simulate a transaction at\n            // `finalized` commitment when your standard of commitment for confirming the\n            // transaction is lower. Cap the simulation commitment level to the level of the\n            // confirmation commitment.\n            preflightCommitment: commitment,\n        };\n    }\n    // The commitment at which the developer wishes to confirm the transaction is at least as\n    // high as the commitment at which they want to simulate it. Honour the config as-is.\n    return config;\n}\n\nexport async function sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendTransactionBaseConfig): Promise<Signature> {\n    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(transaction);\n    return await rpc\n        .sendTransaction(base64EncodedWireTransaction, {\n            ...getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, sendTransactionConfig),\n            encoding: 'base64',\n        })\n        .send({ abortSignal });\n}\n\nexport async function sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmDurableNonceTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmDurableNonceTransactionConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmDurableNonceTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n\nexport async function sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmRecentTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmTransactionWithBlockhashLifetimeConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmRecentTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n","import type { GetAccountInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createNonceInvalidationPromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    waitForDurableNonceTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport { FullySignedTransaction, TransactionWithDurableNonceLifetime } from '@solana/transactions';\n\nimport { sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmDurableNonceTransactionFunction = (\n    transaction: FullySignedTransaction & TransactionWithDurableNonceLifetime,\n    config: Omit<\n        Parameters<typeof sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmDurableNonceTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster> = {\n    rpc: Rpc<GetAccountInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi & SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'devnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'testnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'mainnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster>): SendAndConfirmDurableNonceTransactionFunction {\n    const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({ rpc, rpcSubscriptions } as Parameters<\n        typeof createNonceInvalidationPromiseFactory\n    >[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmDurableNonceTransaction(\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForDurableNonceTransactionConfirmation({\n            ...config,\n            getNonceInvalidationPromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmDurableNonceTransaction(transaction, config) {\n        await sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmDurableNonceTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n","import type { GetEpochInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createBlockHeightExceedencePromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport { FullySignedTransaction, TransactionWithBlockhashLifetime } from '@solana/transactions';\n\nimport { sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFunction = (\n    transaction: FullySignedTransaction & TransactionWithBlockhashLifetime,\n    config: Omit<\n        Parameters<typeof sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmRecentTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster> = {\n    rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'devnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'testnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'mainnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster>): SendAndConfirmTransactionWithBlockhashLifetimeFunction {\n    const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createBlockHeightExceedencePromiseFactory>[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmRecentTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmation({\n            ...config,\n            getBlockHeightExceedencePromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmTransaction(transaction, config) {\n        await sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmRecentTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n","import type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { FullySignedTransaction } from '@solana/transactions';\n\nimport { sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendTransactionWithoutConfirmingFunction = (\n    transaction: FullySignedTransaction,\n    config: Omit<Parameters<typeof sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0], 'rpc' | 'transaction'>,\n) => Promise<void>;\n\ninterface SendTransactionWithoutConfirmingFactoryConfig {\n    rpc: Rpc<SendTransactionApi>;\n}\n\nexport function sendTransactionWithoutConfirmingFactory({\n    rpc,\n}: SendTransactionWithoutConfirmingFactoryConfig): SendTransactionWithoutConfirmingFunction {\n    return async function sendTransactionWithoutConfirming(transaction, config) {\n        await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transaction,\n        });\n    };\n}\n"]}