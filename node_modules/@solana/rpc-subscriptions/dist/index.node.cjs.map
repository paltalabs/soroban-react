{"version":3,"sources":["../src/rpc-integer-overflow-error.ts","../src/rpc-default-config.ts","../src/rpc-subscriptions-autopinger.ts","../src/rpc-subscriptions-channel-pool-internal.ts","../src/rpc-subscriptions-channel-pool.ts","../src/rpc-subscriptions-json.ts","../src/rpc-subscriptions-json-bigint.ts","../src/rpc-subscriptions-channel.ts","../src/rpc-subscriptions-coalescer.ts","../src/rpc-subscriptions-transport.ts","../src/rpc-subscriptions.ts"],"names":["SolanaError","SOLANA_ERROR__RPC__INTEGER_OVERFLOW","safeCaptureStackTrace","isSolanaError","SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED","pipe","transformChannelInboundMessages","transformChannelOutboundMessages","parseJsonWithBigInts","stringifyJsonWithBigints","createWebSocketChannel","fastStableStringify","createSubscriptionRpc","createSolanaRpcSubscriptionsApi"],"mappings":"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","file":"index.node.cjs","sourcesContent":["import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: Partial<\n    NonNullable<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]>\n> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","import { isSolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED } from '@solana/errors';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TChannel extends RpcSubscriptionsChannel<unknown, unknown>> = Readonly<{\n    abortSignal: AbortSignal;\n    channel: TChannel;\n    intervalMs: number;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\nexport function getRpcSubscriptionsChannelWithAutoping<TChannel extends RpcSubscriptionsChannel<object, unknown>>({\n    abortSignal: callerAbortSignal,\n    channel,\n    intervalMs,\n}: Config<TChannel>): TChannel {\n    let intervalId: ReturnType<typeof setInterval> | undefined;\n    function sendPing() {\n        channel.send(PING_PAYLOAD).catch((e: unknown) => {\n            if (isSolanaError(e, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {\n                pingerAbortController.abort();\n            }\n        });\n    }\n    function restartPingTimer() {\n        clearInterval(intervalId);\n        intervalId = setInterval(sendPing, intervalMs);\n    }\n    const pingerAbortController = new AbortController();\n    pingerAbortController.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n    });\n    callerAbortSignal.addEventListener('abort', () => {\n        pingerAbortController.abort();\n    });\n    channel.on(\n        'error',\n        () => {\n            pingerAbortController.abort();\n        },\n        { signal: pingerAbortController.signal },\n    );\n    channel.on('message', restartPingTimer, { signal: pingerAbortController.signal });\n    if (!__BROWSER__ || globalThis.navigator.onLine) {\n        restartPingTimer();\n    }\n    if (__BROWSER__) {\n        globalThis.window.addEventListener(\n            'offline',\n            function handleOffline() {\n                clearInterval(intervalId);\n            },\n            { signal: pingerAbortController.signal },\n        );\n        globalThis.window.addEventListener(\n            'online',\n            function handleOnline() {\n                sendPing();\n                restartPingTimer();\n            },\n            { signal: pingerAbortController.signal },\n        );\n    }\n    return {\n        ...channel,\n        send(...args) {\n            if (!pingerAbortController.signal.aborted) {\n                restartPingTimer();\n            }\n            return channel.send(...args);\n        },\n    };\n}\n","import { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\nexport type ChannelPoolEntry = {\n    channel: PromiseLike<RpcSubscriptionsChannel<unknown, unknown>> | RpcSubscriptionsChannel<unknown, unknown>;\n    readonly dispose: () => void;\n    subscriptionCount: number;\n};\n\ntype ChannelPool = { readonly entries: ChannelPoolEntry[]; freeChannelIndex: number };\n\nexport function createChannelPool(): ChannelPool {\n    return {\n        entries: [],\n        freeChannelIndex: -1,\n    };\n}\n","import { RpcSubscriptionsChannelCreator } from '@solana/rpc-subscriptions-spec';\n\nimport { ChannelPoolEntry, createChannelPool } from './rpc-subscriptions-channel-pool-internal';\n\ntype Config = Readonly<{\n    maxSubscriptionsPerChannel: number;\n    minChannels: number;\n}>;\n\nexport function getChannelPoolingChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<unknown, unknown>,\n>(createChannel: TChannelCreator, { maxSubscriptionsPerChannel, minChannels }: Config): TChannelCreator {\n    const pool = createChannelPool();\n    /**\n     * This function advances the free channel index to the pool entry with the most capacity. It\n     * sets the index to `-1` if all channels are full.\n     */\n    function recomputeFreeChannelIndex() {\n        if (pool.entries.length < minChannels) {\n            // Don't set the free channel index until the pool fills up; we want to keep creating\n            // channels before we start rotating among them.\n            pool.freeChannelIndex = -1;\n            return;\n        }\n        let mostFreeChannel: Readonly<{ poolIndex: number; subscriptionCount: number }> | undefined;\n        for (let ii = 0; ii < pool.entries.length; ii++) {\n            const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;\n            const nextPoolEntry =\n                // Start from the item two positions after the current item. This way, the\n                // search will finish on the item after the current one. This ensures that, if\n                // any channels tie for having the most capacity, the one that will be chosen is\n                // the one immediately to the current one's right (wrapping around).\n                pool.entries[nextPoolIndex];\n            if (\n                nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel &&\n                (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)\n            ) {\n                mostFreeChannel = {\n                    poolIndex: nextPoolIndex,\n                    subscriptionCount: nextPoolEntry.subscriptionCount,\n                };\n            }\n        }\n        pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;\n    }\n    return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {\n        let poolEntry: ChannelPoolEntry;\n        function destroyPoolEntry() {\n            const index = pool.entries.findIndex(entry => entry === poolEntry);\n            pool.entries.splice(index, 1);\n            poolEntry.dispose();\n            recomputeFreeChannelIndex();\n        }\n        if (pool.freeChannelIndex === -1) {\n            const abortController = new AbortController();\n            const newChannelPromise = createChannel({ abortSignal: abortController.signal });\n            newChannelPromise\n                .then(newChannel => {\n                    newChannel.on('error', destroyPoolEntry, { signal: abortController.signal });\n                })\n                .catch(destroyPoolEntry);\n            poolEntry = {\n                channel: newChannelPromise,\n                dispose() {\n                    abortController.abort();\n                },\n                subscriptionCount: 0,\n            };\n            pool.entries.push(poolEntry);\n        } else {\n            poolEntry = pool.entries[pool.freeChannelIndex];\n        }\n        /**\n         * A note about subscription counts.\n         * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n         * materially the same notification will be coalesced on the server. This means they will be\n         * assigned the same subscription id, and will occupy one subscription slot. We can't tell,\n         * from here, whether a subscription will be treated in this way or not, so we\n         * unconditionally increment the subscription count every time a subscription request is\n         * made. This may result in subscription channels being treated as out-of-capacity when in\n         * fact they are not.\n         */\n        poolEntry.subscriptionCount++;\n        abortSignal.addEventListener('abort', function destroyConsumer() {\n            poolEntry.subscriptionCount--;\n            if (poolEntry.subscriptionCount === 0) {\n                destroyPoolEntry();\n            } else if (pool.freeChannelIndex !== -1) {\n                // Back the free channel index up one position, and recompute it.\n                pool.freeChannelIndex--;\n                recomputeFreeChannelIndex();\n            }\n        });\n        recomputeFreeChannelIndex();\n        return poolEntry.channel;\n    } as TChannelCreator;\n}\n","import { pipe } from '@solana/functional';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\nexport function getRpcSubscriptionsChannelWithJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, JSON.parse),\n        c => transformChannelOutboundMessages(c, JSON.stringify),\n    );\n}\n","import { pipe } from '@solana/functional';\nimport { parseJsonWithBigInts, stringifyJsonWithBigints } from '@solana/rpc-spec-types';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\nexport function getRpcSubscriptionsChannelWithBigIntJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, parseJsonWithBigInts),\n        c => transformChannelOutboundMessages(c, stringifyJsonWithBigints),\n    );\n}\n","import { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getRpcSubscriptionsChannelWithAutoping } from './rpc-subscriptions-autopinger';\nimport { getChannelPoolingChannelCreator } from './rpc-subscriptions-channel-pool';\nimport { RpcSubscriptionsChannelCreatorFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsChannelWithJSONSerialization } from './rpc-subscriptions-json';\nimport { getRpcSubscriptionsChannelWithBigIntJSONSerialization } from './rpc-subscriptions-json-bigint';\n\nexport type DefaultRpcSubscriptionsChannelConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    intervalMs?: number;\n    maxSubscriptionsPerChannel?: number;\n    minChannels?: number;\n    sendBufferHighWatermark?: number;\n    url: TClusterUrl;\n}>;\n\nexport function createDefaultSolanaRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization,\n    });\n}\n\nexport function createDefaultRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization,\n    });\n}\n\nfunction createDefaultRpcSubscriptionsChannelCreatorImpl<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl> & {\n        jsonSerializer: (channel: RpcSubscriptionsChannel<string, string>) => RpcSubscriptionsChannel<unknown, unknown>;\n    },\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    if (/^wss?:/i.test(config.url) === false) {\n        const protocolMatch = config.url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? \"Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or \" +\n                  `'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`,\n        );\n    }\n    const { intervalMs, ...rest } = config;\n    const createDefaultRpcSubscriptionsChannel = (({ abortSignal }) => {\n        return createWebSocketChannel({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n            signal: abortSignal,\n        })\n            .then(config.jsonSerializer)\n            .then(channel =>\n                getRpcSubscriptionsChannelWithAutoping({\n                    abortSignal,\n                    channel,\n                    intervalMs: intervalMs ?? 5_000,\n                }),\n            );\n    }) as RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n    return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {\n        maxSubscriptionsPerChannel:\n            config.maxSubscriptionsPerChannel ??\n            /**\n             * A note about this default. The idea here is that, because some RPC providers impose\n             * an upper limit on the number of subscriptions you can make per channel, we must\n             * choose a number low enough to avoid hitting that limit. Without knowing what provider\n             * a given person is using, or what their limit is, we have to choose the lowest of all\n             * known limits. As of this writing (October 2024) that is the public mainnet RPC node\n             * (api.mainnet-beta.solana.com) at 100 subscriptions.\n             */\n            100,\n        minChannels: config.minChannels ?? 1,\n    });\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype CacheEntry = {\n    readonly abortController: AbortController;\n    readonly dataPublisherPromise: Promise<DataPublisher>;\n    numSubscribers: number;\n};\n\nexport function getRpcSubscriptionsTransportWithSubscriptionCoalescing<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n): TTransport {\n    const cache = new Map<string, CacheEntry>();\n    return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {\n        const { request, signal } = config;\n        const subscriptionConfigurationHash = fastStableStringify([request.methodName, request.params]);\n\n        let cachedDataPublisherPromise = cache.get(subscriptionConfigurationHash);\n        if (!cachedDataPublisherPromise) {\n            const abortController = new AbortController();\n            const dataPublisherPromise = transport({\n                ...config,\n                signal: abortController.signal,\n            });\n            dataPublisherPromise\n                .then(dataPublisher => {\n                    dataPublisher.on(\n                        'error',\n                        () => {\n                            cache.delete(subscriptionConfigurationHash);\n                            abortController.abort();\n                        },\n                        { signal: abortController.signal },\n                    );\n                })\n                .catch(() => {});\n            cache.set(\n                subscriptionConfigurationHash,\n                (cachedDataPublisherPromise = {\n                    abortController,\n                    dataPublisherPromise,\n                    numSubscribers: 0,\n                }),\n            );\n        }\n        cachedDataPublisherPromise.numSubscribers++;\n        signal.addEventListener(\n            'abort',\n            () => {\n                cachedDataPublisherPromise.numSubscribers--;\n                if (cachedDataPublisherPromise.numSubscribers === 0) {\n                    queueMicrotask(() => {\n                        if (cachedDataPublisherPromise.numSubscribers === 0) {\n                            cache.delete(subscriptionConfigurationHash);\n                            cachedDataPublisherPromise.abortController.abort();\n                        }\n                    });\n                }\n            },\n            { signal: cachedDataPublisherPromise.abortController.signal },\n        );\n        return cachedDataPublisherPromise.dataPublisherPromise;\n    } as TTransport;\n}\n","import { pipe } from '@solana/functional';\nimport { RpcSubscriptionsChannelCreator, RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport {\n    RpcSubscriptionsChannelCreatorDevnet,\n    RpcSubscriptionsChannelCreatorFromClusterUrl,\n    RpcSubscriptionsChannelCreatorMainnet,\n    RpcSubscriptionsChannelCreatorTestnet,\n    RpcSubscriptionsTransportDevnet,\n    RpcSubscriptionsTransportFromClusterUrl,\n    RpcSubscriptionsTransportMainnet,\n    RpcSubscriptionsTransportTestnet,\n} from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsTransportWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    createChannel: RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n}>;\n\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>({\n    createChannel,\n}: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>) {\n    return pipe(\n        createRpcSubscriptionsTransportFromChannelCreator(\n            createChannel,\n        ) as RpcSubscriptionsTransport as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport),\n    );\n}\n\nexport function createRpcSubscriptionsTransportFromChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage>,\n    TInboundMessage,\n    TOutboundMessage,\n>(createChannel: TChannelCreator) {\n    return (async ({ execute, signal }) => {\n        const channel = await createChannel({ abortSignal: signal });\n        return await execute({ channel, signal });\n    }) as TChannelCreator extends RpcSubscriptionsChannelCreatorDevnet<TOutboundMessage, TInboundMessage>\n        ? RpcSubscriptionsTransportDevnet\n        : TChannelCreator extends RpcSubscriptionsChannelCreatorTestnet<TOutboundMessage, TInboundMessage>\n          ? RpcSubscriptionsTransportTestnet\n          : TChannelCreator extends RpcSubscriptionsChannelCreatorMainnet<TOutboundMessage, TInboundMessage>\n            ? RpcSubscriptionsTransportMainnet\n            : RpcSubscriptionsTransport;\n}\n","import type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport { DEFAULT_RPC_SUBSCRIPTIONS_CONFIG } from './rpc-default-config';\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    DefaultRpcSubscriptionsChannelConfig,\n} from './rpc-subscriptions-channel';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { createDefaultRpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\ntype Config<TClusterUrl extends ClusterUrl> = DefaultRpcSubscriptionsChannelConfig<TClusterUrl>;\n\nfunction createSolanaRpcSubscriptionsImpl<TClusterUrl extends ClusterUrl, TApi extends RpcSubscriptionsApiMethods>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    const transport = createDefaultRpcSubscriptionsTransport({\n        createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl }),\n    });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\nexport function createSolanaRpcSubscriptions<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi>(clusterUrl, config);\n}\n\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return createSubscriptionRpc({\n        api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),\n        transport,\n    }) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n"]}