{"version":3,"sources":["../src/race.ts","../src/abortable.ts"],"names":[],"mappings":"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","file":"index.node.mjs","sourcesContent":["/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n","import { safeRace } from './race';\n\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n"]}