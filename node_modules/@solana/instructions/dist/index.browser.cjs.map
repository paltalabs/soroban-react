{"version":3,"sources":["../src/instruction.ts","../src/roles.ts"],"names":["SolanaError","SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH","SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS","SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA","AccountRole"],"mappings":";;;;;AAwBO,SAAS,uBAAA,CACZ,aACA,cAC0E,EAAA;AAC1E,EAAA,OAAO,YAAY,cAAmB,KAAA,cAAA,CAAA;AAC1C,CAAA;AAEO,SAAS,6BAAA,CACZ,aACA,cACkF,EAAA;AAClF,EAAI,IAAA,WAAA,CAAY,mBAAmB,cAAgB,EAAA;AAC/C,IAAM,MAAA,IAAIA,mBAAYC,qDAAgD,EAAA;AAAA,MAClE,sBAAsB,WAAY,CAAA,cAAA;AAAA,MAClC,sBAAwB,EAAA,cAAA;AAAA,KAC3B,CAAA,CAAA;AAAA,GACL;AACJ,CAAA;AAEO,SAAS,0BAGd,WAA8F,EAAA;AAC5F,EAAA,OAAO,YAAY,QAAa,KAAA,KAAA,CAAA,CAAA;AACpC,CAAA;AAEO,SAAS,gCAGd,WAAsG,EAAA;AACpG,EAAI,IAAA,WAAA,CAAY,aAAa,KAAW,CAAA,EAAA;AACpC,IAAM,MAAA,IAAID,mBAAYE,2DAAsD,EAAA;AAAA,MACxE,MAAM,WAAY,CAAA,IAAA;AAAA,MAClB,gBAAgB,WAAY,CAAA,cAAA;AAAA,KAC/B,CAAA,CAAA;AAAA,GACL;AACJ,CAAA;AAMO,SAAS,sBAGd,WAAsF,EAAA;AACpF,EAAA,OAAO,YAAY,IAAS,KAAA,KAAA,CAAA,CAAA;AAChC,CAAA;AAEO,SAAS,4BAGd,WAA8F,EAAA;AAC5F,EAAI,IAAA,WAAA,CAAY,SAAS,KAAW,CAAA,EAAA;AAChC,IAAM,MAAA,IAAIF,mBAAYG,uDAAkD,EAAA;AAAA,MACpE,kBAAkB,WAAY,CAAA,QAAA,EAAU,GAAI,CAAA,CAAA,CAAA,KAAK,EAAE,OAAO,CAAA;AAAA,MAC1D,gBAAgB,WAAY,CAAA,cAAA;AAAA,KAC/B,CAAA,CAAA;AAAA,GACL;AACJ,CAAA;;;AC/EY,IAAA,WAAA,qBAAAC,YAAL,KAAA;AAEH,EAAAA,YAAA,CAAA,YAAA,CAAA,iBAAA,CAAA;AAAA,EAA0B,CAA1B,CAAA,GAAA,iBAAA,CAAA;AACA,EAAAA,YAAA,CAAA,YAAA,CAAA,iBAAA,CAAA;AAAA,EAA0B,CAA1B,CAAA,GAAA,iBAAA,CAAA;AACA,EAAAA,YAAA,CAAA,YAAA,CAAA,UAAA,CAAA;AAAA,EAA0B,CAA1B,CAAA,GAAA,UAAA,CAAA;AACA,EAAAA,YAAA,CAAA,YAAA,CAAA,UAAA,CAAA;AAAA,EAA0B,CAA1B,CAAA,GAAA,UAAA,CAAA;AALQ,EAAAA,OAAAA,YAAAA,CAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,EAAA,EAAA;AAQZ,IAAM,iBAAoB,GAAA,CAAA,CAAA;AAC1B,IAAM,mBAAsB,GAAA,CAAA,CAAA;AAKrB,SAAS,yBAAyB,IAAgC,EAAA;AACrE,EAAA,OAAO,OAAO,CAAC,iBAAA,CAAA;AACnB,CAAA;AAKO,SAAS,wBAAwB,IAAgC,EAAA;AACpE,EAAA,OAAO,OAAO,CAAC,mBAAA,CAAA;AACnB,CAAA;AAEO,SAAS,aAAa,IAAsF,EAAA;AAC/G,EAAA,OAAO,IAAQ,IAAA,CAAA,uBAAA;AACnB,CAAA;AAEO,SAAS,eAAe,IAA+E,EAAA;AAC1G,EAAA,OAAA,CAAQ,OAAO,mBAAyB,MAAA,CAAA,CAAA;AAC5C,CAAA;AAYO,SAAS,UAAA,CAAW,OAAoB,KAAiC,EAAA;AAC5E,EAAA,OAAO,KAAQ,GAAA,KAAA,CAAA;AACnB,CAAA;AAKO,SAAS,oBAAoB,IAAgC,EAAA;AAChE,EAAA,OAAO,IAAO,GAAA,iBAAA,CAAA;AAClB,CAAA;AAKO,SAAS,sBAAsB,IAAgC,EAAA;AAClE,EAAA,OAAO,IAAO,GAAA,mBAAA,CAAA;AAClB","file":"index.browser.cjs","sourcesContent":["import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { IAccountLookupMeta, IAccountMeta } from './accounts';\n\nexport interface IInstruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: Uint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\nexport interface IInstructionWithAccounts<TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[]>\n    extends IInstruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\nexport interface IInstructionWithData<TData extends Uint8Array> extends IInstruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\n */\n\nexport enum AccountRole {\n    // Bitflag guide: is signer ⌄⌄ is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n"]}