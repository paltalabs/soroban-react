{"version":3,"sources":["../src/deduplicate-signers.ts","../src/transaction-modifying-signer.ts","../src/transaction-partial-signer.ts","../src/transaction-sending-signer.ts","../src/transaction-signer.ts","../src/account-signer-meta.ts","../src/add-signers.ts","../src/fee-payer-signer.ts","../src/message-partial-signer.ts","../src/keypair-signer.ts","../src/message-modifying-signer.ts","../src/message-signer.ts","../src/noop-signer.ts","../src/transaction-with-single-sending-signer.ts","../src/sign-transaction.ts","../../text-encoding-impl/src/index.browser.ts","../src/signable-message.ts"],"names":["SolanaError","SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS","SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER","SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER","SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER","SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER","isSignerRole","SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER","SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER","getAddressFromPublicKey","signBytes","transactions","partiallySignTransaction","generateKeyPair","createKeyPairFromBytes","createKeyPairFromPrivateKeyBytes","isAddress","SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER","SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING","SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS","assertTransactionIsFullySigned","compileTransaction","transaction","TextEncoder"],"mappings":"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","file":"index.browser.cjs","sourcesContent":["import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Removes all duplicated signers from a provided array by comparing their addresses. */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions<T extends Transaction>(\n        transactions: readonly T[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly T[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly Transaction[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/** Defines a signer capable of signing and sending transactions simultaneously. */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly Transaction[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link TransactionSigner} interface. */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link TransactionSigner} interface. */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    ITransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { ITransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/** An extension of the IAccountMeta type that keeps track of its transaction signer. */\nexport interface IAccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends IAccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\ntype IAccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | IAccountLookupMeta\n    | IAccountMeta\n    | IAccountSignerMeta<string, TSigner>;\n\n/** A variation of the instruction type that allows IAccountSignerMeta in its account metas. */\nexport type IInstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Pick<IInstruction<string, TAccounts>, 'accounts'>;\n\n/** A variation of the transaction message type that allows IAccountSignerMeta in its account metas. */\nexport type ITransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Partial<ITransactionMessageWithFeePayer<TAddress> | ITransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, IInstruction & IInstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/** Extract all signers from an instruction that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: IInstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/** Extract all signers from a transaction message that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends ITransactionMessageWithSigners<TAddress, TSigner> = ITransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { IInstruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage } from '@solana/transaction-messages';\n\nimport { IAccountSignerMeta, IInstructionWithSigners, ITransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Attaches the provided signers to the account metas of an instruction when applicable. */\nexport function addSignersToInstruction<TInstruction extends IInstruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (IInstructionWithSigners & TInstruction),\n): IInstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as IInstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as IAccountSignerMeta);\n        }),\n    });\n}\n\n/** Attaches the provided signers to the account metas of a transaction message when applicable. */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (ITransactionMessageWithSigners & TTransactionMessage),\n): ITransactionMessageWithSigners & TTransactionMessage {\n    if (transactionMessage.instructions.length === 0) {\n        return transactionMessage as ITransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n","import { BaseTransactionMessage, ITransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\nexport interface ITransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage &\n        Partial<ITransactionMessageWithFeePayer | ITransactionMessageWithFeePayerSigner>,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ITransactionMessageWithFeePayerSigner<TFeePayerAddress> & Omit<TTransactionMessage, 'feePayer'> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessagePartialSigner} interface. */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/** Asserts that the provided value implements the {@link MessagePartialSigner} interface. */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a signer capable of signing messages and transactions using a CryptoKeyPair. */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/** Checks whether the provided value implements the {@link KeyPairSigner} interface. */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link KeyPairSigner} interface. */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/** Creates a KeyPairSigner from the provided Crypto KeyPair. */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/** Securely generates a signer capable of signing messages and transactions using a Crypto KeyPair. */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/** Creates a signer capable of signing messages and transactions using the 64 bytes of a KeyPair. */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/** Creates a signer capable of signing messages and transactions using the 32 bytes of a private key. */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/** Asserts that the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/** Defines a signer capable of signing messages. */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link MessageSigner} interface. */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/** Asserts that the provided value implements the {@link MessageSigner} interface. */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a no-operation signer that pretends to partially sign messages and transactions. */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/** Creates a NoopSigner from the provided Address. */\nexport function createNoopSigner(address: Address): NoopSigner {\n    const out: NoopSigner = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { CompilableTransactionMessage } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, ITransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/** Defines a transaction message with exactly one {@link TransactionSendingSigner}. */\nexport type ITransactionMessageWithSingleSendingSigner = ITransactionMessageWithSigners & {\n    readonly __transactionWithSingleSendingSigner: unique symbol;\n};\n\n/** Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}. */\nexport function isTransactionMessageWithSingleSendingSigner<TTransactionMessage extends CompilableTransactionMessage>(\n    transaction: TTransactionMessage,\n): transaction is ITransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/** Asserts that the provided transaction has exactly one {@link TransactionSendingSigner}. */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends CompilableTransactionMessage,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is ITransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport {\n    CompilableTransactionMessage,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\nimport {\n    assertTransactionIsFullySigned,\n    compileTransaction,\n    FullySignedTransaction,\n    Transaction,\n    TransactionWithBlockhashLifetime,\n    TransactionWithDurableNonceLifetime,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, ITransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\ntype CompilableTransactionMessageWithSigners = CompilableTransactionMessage & ITransactionMessageWithSigners;\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Transaction & TransactionWithBlockhashLifetime>;\n\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithDurableNonceLifetime>>;\n\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithLifetime>>;\n\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithLifetime>> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will assert that the transaction is fully signed before returning.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithBlockhashLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithBlockhashLifetime>>;\n\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime = CompilableTransactionMessageWithSigners &\n        TransactionMessageWithDurableNonceLifetime,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithDurableNonceLifetime>>;\n\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithLifetime>>;\n\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<Readonly<FullySignedTransaction & TransactionWithLifetime>> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertTransactionIsFullySigned(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Signs and sends a transaction using any signers that may be stored in IAccountSignerMeta\n * instruction accounts as well as any signers provided explicitly to this function.\n * It will identify a single TransactionSendingSigners to use for sending the transaction, if any.\n * Otherwise, it will send the transaction using the provided fallbackSender.\n */\nexport async function signAndSendTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(transaction: TTransactionMessage, config?: TransactionSendingSignerConfig): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<Readonly<Transaction & TransactionWithLifetime>> {\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    );\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n    const signedTransaction: Readonly<Transaction & TransactionWithLifetime> = {\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    };\n\n    return Object.freeze(signedTransaction);\n}\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/** Defines a message that needs signing and its current set of signatures if any. */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a signable message from a provided content.\n * If a string is provided, it will be UTF-8 encoded.\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n"]}