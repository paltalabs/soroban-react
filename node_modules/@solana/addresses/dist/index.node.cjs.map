{"version":3,"sources":["../src/address.ts","../src/vendor/noble/ed25519.ts","../src/curve.ts","../src/program-derived-address.ts","../src/public-key.ts"],"names":["getBase58Encoder","getBase58Decoder","SolanaError","SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE","SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH","transformEncoder","fixEncoderSize","fixDecoderSize","combineCodec","SOLANA_ERROR__ADDRESSES__MALFORMED_PDA","SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE","assertDigestCapabilityIsAvailable","SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED","SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED","SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE","address","isSolanaError","SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED","SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER","assertKeyExporterIsAvailable","SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY"],"mappings":"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","file":"index.node.cjs","sourcesContent":["import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Address<TAddress extends string = string> = TAddress & {\n    readonly __brand: unique symbol;\n};\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7); // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y²\n    const u = mod(y2 - 1n); // u=y²-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: Uint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: Uint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport type { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve';\n\n/**\n * An address derived from a program address and a set of seeds.\n * It includes the bump seed used to derive the address and\n * ensure the address is not on the Ed25519 curve.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * A number between 0 and 255, inclusive.\n */\nexport type ProgramDerivedAddressBump = number & {\n    readonly __brand: unique symbol;\n};\n\n/**\n * Returns true if the input value is a program derived address.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * Fails if the input value is not a program derived address.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder } from './address';\n\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n"]}