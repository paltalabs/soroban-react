{"version":3,"sources":["../src/private-key.ts","../src/public-key.ts","../src/signatures.ts","../src/key-pair.ts"],"names":["SolanaError","SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH","assertKeyExporterIsAvailable","SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY","getBase58Encoder","SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE","SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH","assertSigningCapabilityIsAvailable","signature","assertVerificationCapabilityIsAvailable","assertKeyGenerationIsAvailable","assertPRNGIsAvailable","SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH","SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY","privateKey"],"mappings":"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","file":"index.node.cjs","sourcesContent":["import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\nexport async function createPrivateKeyFromBytes(bytes: ReadonlyUint8Array, extractable?: boolean): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, 'Ed25519', extractable ?? false, ['sign']);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Signature = string & { readonly __brand: unique symbol };\nexport type SignatureBytes = Uint8Array & { readonly __brand: unique symbol };\n\nlet base58Encoder: Encoder<string> | undefined;\n\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        return false;\n    }\n    return true;\n}\n\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign('Ed25519', key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify('Ed25519', key, signature, data);\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ 'Ed25519', // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\nexport async function createKeyPairFromBytes(bytes: ReadonlyUint8Array, extractable?: boolean): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), 'Ed25519', /* extractable */ true, ['verify']),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n"]}