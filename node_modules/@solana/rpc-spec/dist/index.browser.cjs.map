{"version":3,"sources":["../src/rpc.ts","../src/rpc-api.ts","../src/rpc-transport.ts"],"names":["SolanaError","SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD","createRpcMessage"],"mappings":"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","file":"index.browser.cjs","sourcesContent":["import { SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\n\nimport { RpcApi, RpcPlan } from './rpc-api';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\nexport type PendingRpcRequest<TResponse> = {\n    send(options?: RpcSendOptions): Promise<TResponse>;\n};\n\nexport type RpcSendOptions = Readonly<{\n    abortSignal?: AbortSignal;\n}>;\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams,\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    { transport }: RpcConfig<TRpcMethods, TRpcTransport>,\n    plan: RpcPlan<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            return await plan.execute({ signal: options?.abortSignal, transport });\n        },\n    };\n}\n","import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    requestTransformer?: RpcRequestTransformer;\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n","import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    payload: unknown;\n    signal?: AbortSignal;\n}>;\n\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n"]}