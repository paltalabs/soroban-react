export type AllowedHttpRequestHeaders = Readonly<{
    [K in DisallowedHeaders | ForbiddenHeaders as Capitalize<Lowercase<K>> | K | Lowercase<K> | Uncapitalize<K> | Uppercase<K>]?: never;
} & {
    [headerName: string]: string;
}>;
type DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';
type ForbiddenHeaders = 'Accept-Charset'
/**
 * Though technically forbidden in non-Node environments, we don't have a way to target
 * TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is
 * therefore omitted from the forbidden headers type, but is still a runtime error in dev mode
 * when supplied in a non-Node context.
 */
 | 'Access-Control-Request-Headers' | 'Access-Control-Request-Method' | 'Connection' | 'Content-Length' | 'Cookie' | 'Date' | 'DNT' | 'Expect' | 'Host' | 'Keep-Alive' | 'Origin' | 'Permissions-Policy' | 'Referer' | 'TE' | 'Trailer' | 'Transfer-Encoding' | 'Upgrade' | 'Via' | `Proxy-${string}` | `Sec-${string}`;
export declare function assertIsAllowedHttpRequestHeaders(headers: Record<string, string>): asserts headers is AllowedHttpRequestHeaders;
/**
 * Lowercasing header names makes it easier to override user-supplied headers, such as those defined
 * in the `DisallowedHeaders` type.
 */
export declare function normalizeHeaders<T extends Record<string, string>>(headers: T): {
    [K in string & keyof T as Lowercase<K>]: T[K];
};
export {};
//# sourceMappingURL=http-transport-headers.d.ts.map