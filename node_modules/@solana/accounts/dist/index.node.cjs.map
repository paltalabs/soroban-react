{"version":3,"sources":["../src/account.ts","../src/decode-account.ts","../src/parse-account.ts","../src/fetch-account.ts","../src/maybe-account.ts"],"names":["SolanaError","SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT","SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT","SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED","getBase64Encoder","getBase58Encoder","SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND","SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND"],"mappings":"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","file":"index.node.cjs","sourcesContent":["import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/** The amount of bytes required to store the base account information without its data. */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/** Describe the generic account details applicable to every account. */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n};\n\n/** Defines a Solana account with its generic details and parsed or encoded data. */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/** Defines a Solana account with its generic details and encoded data. */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/** Decodes the data of a given account using the provided decoder. */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/** Asserts that an account has been decoded. */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/** Asserts that all accounts have been decoded. */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/** Parse an account object received from a base64-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/** Parse an account object received from a base58-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/** Parse an account object received from a json-parsed RPC call into an Account or MaybeAccount type. */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/** Optional configuration for fetching a singular account. */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch a base64-encoded account that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/** Fetch a json-parsed account that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/** Optional configuration for fetching multiple accounts. */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch multiple base64-encoded accounts that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/** Fetch multiple json-parsed accounts that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/** Defines a Solana account that may or may not exist after having tried to fetch it. */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/** Defines a Solana account with encoded data that may or may not exist after having tried to fetch it. */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/** Asserts that an account that may or may not exists, actually exists. */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/** Asserts that all accounts that may or may not exist, actually all exist. */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n"]}